

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>interfaces.interfaces &mdash; covgDAQ 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> covgDAQ
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Register.html">Register Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Endpoint.html">Endpoint Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FPGA.html">FPGA Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../I2CController.html">I2C Controller Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../SPIController.html">SPI Controller Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../SPIFifoDriven.html">SPI FIFO Driven Controller Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DDR.html">DDR Memory Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../register_index_guide.html">Register Index Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../endpoint_definitions_guide.html">Endpoint Definitions Guide</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">covgDAQ</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>interfaces.interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for interfaces.interfaces</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for configuring OpalKelly XEM7310</span>
<span class="sd">and use it as an I2C controller, SPI controller, and Serial LVDS controller.</span>

<span class="sd">Lucas Koerner, koer2434@stthomas.edu</span>
<span class="sd">Abe Stroschein, ajstroschein@stthomas.edu</span>
<span class="sd">August 2021</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">ok</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">interfaces.utils</span> <span class="kn">import</span> <span class="n">gen_mask</span><span class="p">,</span> <span class="n">twos_comp</span><span class="p">,</span> <span class="n">test_bit</span><span class="p">,</span> <span class="n">int_to_list</span><span class="p">,</span> <span class="n">from_voltage</span><span class="p">,</span> <span class="n">to_voltage</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<div class="viewcode-block" id="Register"><a class="viewcode-back" href="../../Register.html#interfaces.interfaces.Register">[docs]</a><span class="k">class</span> <span class="nc">Register</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for internal registers on a device.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    address : int</span>
<span class="sd">        Address location of the register.</span>
<span class="sd">    default : int</span>
<span class="sd">        Default value of the register.</span>
<span class="sd">    bit_index_high : int</span>
<span class="sd">        Index of the MSB in the register.</span>
<span class="sd">    bit_index_low : int</span>
<span class="sd">        Index of the LSB in the register.</span>
<span class="sd">    bit_width : int</span>
<span class="sd">        Width of the register in bits.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">bit_index_high</span><span class="p">,</span> <span class="n">bit_index_low</span><span class="p">,</span> <span class="n">bit_width</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">=</span> <span class="n">bit_index_high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">=</span> <span class="n">bit_index_low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_width</span> <span class="o">=</span> <span class="n">bit_width</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bit_index_low</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">bit_index_high</span><span class="si">}</span><span class="s1">]&#39;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Register.get_chip_registers"><a class="viewcode-back" href="../../Register.html#interfaces.interfaces.Register.get_chip_registers">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_chip_registers</span><span class="p">(</span><span class="n">sheet</span><span class="p">,</span> <span class="n">workbook_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary of Registers from a page in an Excel spreadsheet.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">workbook_path</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">workbook_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="c1"># The Registers spreadsheet is located in the covg_fpga folder so we need to find that folder. If it is not above the current directory, the program fails.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">workbook_path</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;covg_fpga&#39;</span><span class="p">:</span>
                    <span class="n">workbook_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">workbook_path</span><span class="p">,</span> <span class="s1">&#39;python&#39;</span><span class="p">,</span> <span class="s1">&#39;Registers.xlsx&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If we aren&#39;t in covg_fpga, move up a folder and check again</span>
                    <span class="n">workbook_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">workbook_path</span><span class="p">)</span>

        <span class="n">reg_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">sheet_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="n">workbook_path</span><span class="p">,</span> <span class="n">sheet</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sheet_data</span><span class="p">)):</span>
            <span class="n">row_data</span> <span class="o">=</span> <span class="n">sheet_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="n">reg_dict</span><span class="p">[</span><span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Register</span><span class="p">(</span>
                <span class="n">address</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Hex Address&#39;</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Default Value&#39;</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span>
                <span class="n">bit_width</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Bit Width&#39;</span><span class="p">]),</span>
                <span class="n">bit_index_high</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Bit Index (High)&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Bit Index (High)&#39;</span><span class="p">])),</span>  <span class="c1"># Bit Index of None means the register takes up the whole endpoint</span>
                <span class="n">bit_index_low</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Bit Index (Low)&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">row_data</span><span class="p">[</span><span class="s1">&#39;Bit Index (Low)&#39;</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">reg_dict</span></div></div>


<div class="viewcode-block" id="Endpoint"><a class="viewcode-back" href="../../Endpoint.html#interfaces.interfaces.Endpoint">[docs]</a><span class="k">class</span> <span class="nc">Endpoint</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for Opal Kelly endpoints on the FPGA.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    endpoints_from_defines : dict</span>
<span class="sd">        Class attribute. Dictionary of each group of endpoints paired with inner dictionaries</span>
<span class="sd">        of endpoint names to Endpoint objects, starts empty.</span>
<span class="sd">    I2CDAQ_level_shifted : dict</span>
<span class="sd">        Class attribute. Dictionary of Endpoints for the level shifted I2CDAQ bus.</span>
<span class="sd">    I2CDAQ_QW : dict</span>
<span class="sd">        Class attribute. Dictionary of Endpoints for QW 3.3V I2CDAQ bus.</span>
<span class="sd">    address : int</span>
<span class="sd">        Address location of the Endpoint.</span>
<span class="sd">    bit_index_low : int</span>
<span class="sd">        Index of the LSB of the Endpoint.</span>
<span class="sd">    bit_index_high : int</span>
<span class="sd">        Index of the MSB of the Endpoint.</span>
<span class="sd">    bit_width : int</span>
<span class="sd">        Width of the Endpoint in bits.</span>
<span class="sd">    gen_bit : bool</span>
<span class="sd">        Whether to increment the bits when incrementing the endpoint.</span>
<span class="sd">    gen_address : bool</span>
<span class="sd">        Whether to increment the address when incrementing the endpoint.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">endpoints_from_defines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">I2CDAQ_level_shifted</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">I2CDAQ_QW</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">bit_index_low</span><span class="p">,</span> <span class="n">bit_width</span><span class="p">,</span> <span class="n">gen_bit</span><span class="p">,</span> <span class="n">gen_address</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">=</span> <span class="n">bit_index_low</span>
        <span class="c1"># Endpoints that are only containing addresses will be generated from ep_defines.v with bit_index_low = None</span>
        <span class="k">if</span> <span class="n">bit_index_low</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">=</span> <span class="n">bit_index_low</span> <span class="o">+</span> <span class="n">bit_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_width</span> <span class="o">=</span> <span class="n">bit_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_bit</span> <span class="o">=</span> <span class="n">gen_bit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_address</span> <span class="o">=</span> <span class="n">gen_address</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_rep</span> <span class="o">=</span> <span class="s1">&#39;0x</span><span class="si">{:0x}</span><span class="s1">[</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_rep</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Endpoint.update_endpoints_from_defines"><a class="viewcode-back" href="../../Endpoint.html#interfaces.interfaces.Endpoint.update_endpoints_from_defines">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">update_endpoints_from_defines</span><span class="p">(</span><span class="n">ep_defines_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store and return a dictionary of Endpoints for each chip in ep_defines.v.</span>

<span class="sd">        Returns -1 if there is a naming collision in ep_defines.v</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find ep_defines.v path</span>
        <span class="k">if</span> <span class="n">ep_defines_path</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ep_defines_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="c1"># The Registers spreadsheet is located in the covg_fpga folder so we need to find that folder. If it is not above the current directory, the program fails.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ep_defines_path</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;covg_fpga&#39;</span><span class="p">:</span>
                    <span class="n">ep_defines_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">ep_defines_path</span><span class="p">,</span> <span class="s1">&#39;fpga_XEM7310&#39;</span><span class="p">,</span> <span class="s1">&#39;fpga_XEM7310.srcs&#39;</span><span class="p">,</span> <span class="s1">&#39;sources_1&#39;</span><span class="p">,</span> <span class="s1">&#39;ep_defines.v&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If we aren&#39;t in covg_fpga, move up a folder and check again</span>
                    <span class="n">ep_defines_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">ep_defines_path</span><span class="p">)</span>

        <span class="c1"># Get all lines</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">ep_defines_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="c1"># Get all the endpoints from the lines</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="c1"># Check if the line defines an endpoint</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="c1"># Ex. line = &quot;`define AD7961_PIPE_OUT_GEN_ADDR 8&#39;hA1 // address=TEST_ADDRESS bit_width=32&quot;</span>
            <span class="c1">#   pieces = [&quot;`define&quot;, &quot;AD7961_PIPE_OUT_GEN_ADDR&quot;, &quot;8&#39;hA1&quot;, &quot;//&quot;, &quot;address=TEST_ADDRESS&quot;, &quot;bit_width=32&quot;]</span>
            <span class="k">if</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;`define&#39;</span><span class="p">:</span>
                <span class="c1"># Line does not define an endpoint, skip</span>
                <span class="k">continue</span>

            <span class="c1"># Extract data from definition</span>
            <span class="c1"># Class name</span>
            <span class="n">class_name_end</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">class_name_end</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># .find() returns -1 if not found, without an underscore we cannot</span>
                <span class="c1"># tell where the class and endpoint names are separated</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FAIL: no endpoint name found&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">class_name</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">class_name_end</span><span class="p">]</span>

            <span class="c1"># Whether to generate bits</span>
            <span class="n">remaining_name</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">class_name_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">previous_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_name</span><span class="p">)</span>
            <span class="n">remaining_name</span> <span class="o">=</span> <span class="n">remaining_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_GEN_BIT&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># If the remaining name is shorter it is because GEN_BIT was replaced</span>
            <span class="n">gen_bit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">previous_len</span>

            <span class="c1"># Whether to generate address</span>
            <span class="n">previous_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_name</span><span class="p">)</span>
            <span class="n">remaining_name</span> <span class="o">=</span> <span class="n">remaining_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_GEN_ADDR&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># If the remaining name is shorter it is because GEN_ADDR was replaced</span>
            <span class="n">gen_address</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">previous_len</span>

            <span class="c1"># Endpoint name</span>
            <span class="n">ep_name</span> <span class="o">=</span> <span class="n">remaining_name</span>
            <span class="k">if</span> <span class="n">ep_name</span> <span class="o">==</span> <span class="s1">&#39;NUM_OUTGOING_EPS&#39;</span><span class="p">:</span>
                <span class="c1"># This is not an endpoint and does not match the</span>
                <span class="c1"># format of the others so we skip it</span>
                <span class="k">continue</span>

            <span class="c1"># Address, bit, and bit_width</span>
            <span class="k">if</span> <span class="s2">&quot;8&#39;h&quot;</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="c1"># Definition holds an address, take that value</span>
                <span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">:],</span> <span class="n">base</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">bit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">bit_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pieces</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Definition holds a bit, take address from comment</span>
                <span class="n">comment_address</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;0x&#39;</span> <span class="ow">in</span> <span class="n">comment_address</span><span class="p">:</span>
                    <span class="c1"># Address comment has a hex value</span>
                    <span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">comment_address</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Address comment has the name of another endpoint so store</span>
                    <span class="c1"># the interfaces.py name of that endpoint so we can look it</span>
                    <span class="c1"># up going through all lines</span>
                    <span class="n">address_name</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">address_name_no_gen</span> <span class="o">=</span> <span class="n">address_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                        <span class="s1">&#39;_GEN&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">address</span> <span class="o">=</span> <span class="n">address_name_no_gen</span>
                <span class="n">bit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">bit_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pieces</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">endpoint</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="p">(</span><span class="n">address</span><span class="o">=</span><span class="n">address</span><span class="p">,</span> <span class="n">bit_index_low</span><span class="o">=</span><span class="n">bit</span><span class="p">,</span> <span class="n">bit_width</span><span class="o">=</span><span class="n">bit_width</span><span class="p">,</span> <span class="n">gen_bit</span><span class="o">=</span><span class="n">gen_bit</span><span class="p">,</span> <span class="n">gen_address</span><span class="o">=</span><span class="n">gen_address</span><span class="p">)</span>

            <span class="c1"># Put defined endpoint in endpoints_from_defines dictionary</span>
            <span class="k">if</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Class doesn&#39;t exist yet in the dictionary</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">ep_name</span><span class="p">:</span> <span class="n">endpoint</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Class already exists in the dictionary</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="p">[</span><span class="n">class_name</span><span class="p">][</span><span class="n">ep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoint</span>

        <span class="c1"># Go through endpoints_from_defines and find hex addresses for those with endpoint</span>
        <span class="c1"># name references instead</span>
        <span class="k">for</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">endpoint_name</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">endpoint</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">endpoint_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">address</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="c1"># Address is a name</span>
                    <span class="n">class_name</span><span class="p">,</span> <span class="n">ep_name</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                        <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">referenced_group</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">class_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">referenced_group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">endpoint_name</span><span class="si">}</span><span class="s1">]: Referenced group &quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s1">&quot; not found.&#39;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">referenced_endpoint</span> <span class="o">=</span> <span class="n">referenced_group</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ep_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">referenced_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">endpoint_name</span><span class="si">}</span><span class="s1">]: Referenced endpoint &quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">ep_name</span><span class="si">}</span><span class="s1">&quot; not found.&#39;</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">endpoint</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">referenced_endpoint</span><span class="o">.</span><span class="n">address</span>

        <span class="c1"># At this point the dictionary should be built</span>
        <span class="c1"># Check for naming collisions (2+ names sharing same address or bit within address)</span>
        <span class="c1"># Collect all top level endpoints</span>
        <span class="n">top_level_eps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">Endpoint</span><span class="p">]</span>
        <span class="c1"># Collect all endpoints in dictionaries</span>
        <span class="n">lower_level_eps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">eps</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">]:</span>
            <span class="n">lower_level_eps</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">none_to_neg_1</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="c1"># Make tuples of (address, bit) from each list, then concatenate the lists</span>
        <span class="c1"># The none_to_neg_1.get() translates None values of bit_index_low to -1 for sorting later</span>
        <span class="n">list_eps</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ep</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">none_to_neg_1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ep</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">ep</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">))</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">top_level_eps</span><span class="p">]</span>
        <span class="n">list_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_eps</span><span class="p">)</span>
        <span class="n">set_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list_eps</span><span class="p">))</span>  <span class="c1"># A set removes duplicates</span>

        <span class="k">if</span> <span class="n">list_len</span> <span class="o">!=</span> <span class="n">set_len</span><span class="p">:</span>
            <span class="c1"># There may be duplicates. May not, because different groups can have endpoints of the same name.</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Checking for naming collisions in ep_defines.v ...&#39;</span><span class="p">)</span>

            <span class="c1"># Search through to find duplicates</span>
            <span class="c1"># Copy the list to keep order in the original</span>
            <span class="n">sorted_list_eps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_eps</span><span class="p">)</span>
            <span class="n">sorted_list_eps</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># Put duplicates next to one another in new list</span>
            <span class="n">top_level_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">==</span> <span class="n">Endpoint</span><span class="p">]</span>
            <span class="n">lower_level_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sub_dicts</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">]:</span>
                <span class="n">lower_level_names</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub_dicts</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">list_names</span> <span class="o">=</span> <span class="n">top_level_names</span> <span class="o">+</span> <span class="n">lower_level_names</span>

            <span class="n">collision</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Keep track of whether there was a collision for return value</span>
            <span class="k">for</span> <span class="n">ep_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_list_eps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">ep</span> <span class="o">=</span> <span class="n">sorted_list_eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">]</span>
                <span class="n">next_ep</span> <span class="o">=</span> <span class="n">sorted_list_eps</span><span class="p">[</span><span class="n">ep_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">list_names</span><span class="p">[</span><span class="n">list_eps</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sorted_list_eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">])]</span>
                <span class="n">next_name</span> <span class="o">=</span> <span class="n">list_names</span><span class="p">[</span><span class="n">list_eps</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                    <span class="n">sorted_list_eps</span><span class="p">[</span><span class="n">ep_index</span><span class="p">])]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ep</span> <span class="o">==</span> <span class="n">next_ep</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">next_name</span><span class="p">):</span>
                    <span class="c1"># Need different names because otherwise they are from different groups and do not actually conflict</span>

                    <span class="c1"># The name part of this uses a list of names created in the same order as the original list_eps (list_names)</span>
                    <span class="c1"># then finds the index of the current endpoint in list_eps and uses that to find the corresponding</span>
                    <span class="c1"># name in list_names</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Collision found at address=</span><span class="si">{</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bit=</span><span class="si">{</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="n">next_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">collision</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No collisions found.&#39;</span><span class="p">)</span>

        <span class="c1"># If the list and set match length, no duplicates</span>
        <span class="k">return</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span></div>

<div class="viewcode-block" id="Endpoint.get_chip_endpoints"><a class="viewcode-back" href="../../Endpoint.html#interfaces.interfaces.Endpoint.get_chip_endpoints">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_chip_endpoints</span><span class="p">(</span><span class="n">chip_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the dictionary of Endpoints for a specific chip or group.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">():</span>
            <span class="n">Endpoint</span><span class="o">.</span><span class="n">update_endpoints_from_defines</span><span class="p">()</span>

        <span class="c1"># copy.deepcopy() is important here because it makes a copy of the</span>
        <span class="c1"># dictionary so that when we increment it for multiple instantiations</span>
        <span class="c1"># of the chip, each previously instantiated chip will not have its</span>
        <span class="c1"># endpoints affected by the increment, only future instantiations.</span>
        <span class="c1"># Using deepcopy() ensures that any dictionaries inside the dictionary</span>
        <span class="c1"># we copy also get copied, not left as references.</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chip_name</span><span class="p">))</span></div>

<div class="viewcode-block" id="Endpoint.increment_endpoints"><a class="viewcode-back" href="../../Endpoint.html#interfaces.interfaces.Endpoint.increment_endpoints">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">increment_endpoints</span><span class="p">(</span><span class="n">endpoints_dict</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Increment all Endpoints in endpoints_dict.</span>

<span class="sd">        Use each Endpoint&#39;s gen_bit and gen_addr values to determine whether to</span>
<span class="sd">        increment bits and addresses, respectively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endpoints_dict : dict</span>
<span class="sd">            The dict of Endpoints to increment.</span>
<span class="sd">        in_place : bool</span>
<span class="sd">            If True, the dictionary given will be changed. Otherwise, a copy</span>
<span class="sd">            of the dictionary will be made.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="c1"># Make a copy</span>
            <span class="n">endpoints_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">endpoints_dict</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">endpoints_dict</span><span class="p">:</span>
            <span class="n">endpoint</span> <span class="o">=</span> <span class="n">endpoints_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_bit</span> <span class="ow">and</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_address</span><span class="p">:</span>
                <span class="c1"># Increment the bit by the endpoint&#39;s bit_width and if it would</span>
                <span class="c1"># go outside the address&#39;s width, increment the address</span>
                <span class="c1"># TODO: do we want to wrap around the bits on the same address, -&gt; can change address on each bit individually</span>
                <span class="c1"># or shift all bits when one moves to the next address? -&gt; each bit needs to know if other bits fit on the current address as well</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_bit</span><span class="p">:</span>
                <span class="c1"># Increment the bit by the bit_width</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_width</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_width</span>
            <span class="k">elif</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_address</span><span class="p">:</span>
                <span class="c1"># Increment the address by 1</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">address</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">endpoints_dict</span></div>

<div class="viewcode-block" id="Endpoint.excel_to_defines"><a class="viewcode-back" href="../../Endpoint.html#interfaces.interfaces.Endpoint.excel_to_defines">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">excel_to_defines</span><span class="p">(</span><span class="n">excel_path</span><span class="p">,</span> <span class="n">defines_path</span><span class="p">,</span> <span class="n">sheet</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an Excel spreadsheet of endpoint definitions to Verilog.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel_path : str</span>
<span class="sd">            The path to the Excel spreadsheet to convert.</span>
<span class="sd">        defines_path : str</span>
<span class="sd">            The path to the Verilog file to create.</span>
<span class="sd">        sheet : int or str</span>
<span class="sd">            Optional. The int index of the sheet to read from the Excel</span>
<span class="sd">            spreadsheet, or the str sheet name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str : the text written to the Verilog file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sheet_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span><span class="n">excel_path</span><span class="p">,</span> <span class="n">sheet</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sheet_data</span><span class="p">[</span><span class="s1">&#39;Generated Line&#39;</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">defines_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">text</span></div></div>


<span class="k">def</span> <span class="nf">advance_endpoints_bynum</span><span class="p">(</span><span class="n">endpoints_dict</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Advance endpoints by a specific number; calculates based on the bit_widths</span>
<span class="sd">    and knowing that the width of the OK interface is 32 bits.</span>
<span class="sd">    Just a method of an Endpoint (not a classmethod).</span>
<span class="sd">    Goal is to not impact future device instantiations.</span>

<span class="sd">    Example usage:</span>
<span class="sd">        endpoints=Endpoint.advance_endpoints_bynum(Endpoint.get_chip_endpoints(&#39;I2CDAQ&#39;),1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number to advance is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
    <span class="c1"># num is the number to advance from the base addresses and bits</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">endpoints_dict</span><span class="p">:</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="n">endpoints_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_bit</span><span class="p">:</span>
            <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="p">(</span><span class="n">endpoint</span><span class="o">.</span><span class="n">bit_width</span><span class="o">*</span><span class="n">num</span><span class="p">))</span>
            <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">=</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">bit_width</span>
        <span class="k">if</span> <span class="n">endpoint</span><span class="o">.</span><span class="n">gen_address</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;gen address bit_width: </span><span class="si">{</span><span class="n">endpoint</span><span class="o">.</span><span class="n">bit_width</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">endpoint</span><span class="o">.</span><span class="n">address</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">endpoints_dict</span>

<span class="c1"># Class for the FPGA itself. Handles FPGA configuration, setting wire values,</span>
<span class="c1"># and other FPGA specific functions.</span>


<div class="viewcode-block" id="FPGA"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA">[docs]</a><span class="k">class</span> <span class="nc">FPGA</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for the Opal Kelly FPGA itself.</span>
<span class="sd">    Derived from OpalKelly Python examples.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    bitfile : str</span>
<span class="sd">        Path to the bitfile to load on the FPGA.</span>
<span class="sd">    xem : ok.okCFrontPanel</span>
<span class="sd">        Opal Kelly API connection to the FPGA.</span>
<span class="sd">    device_info : ok.okTDeviceInfo</span>
<span class="sd">        General information about the FPGA.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: change to complete bitfile when Verilog is combined</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bitfile</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bitfile</span> <span class="o">=</span> <span class="n">bitfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="c1"># self.pll = ok.PLL22150()</span>
        <span class="c1"># I don&#39;t know why, but uncommenting this makes things fail</span>
        <span class="k">return</span>

<div class="viewcode-block" id="FPGA.init_device"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.init_device">[docs]</a>    <span class="k">def</span> <span class="nf">init_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the FPGA for use and print device information.</span>

<span class="sd">        Connect to the FPGA and load the bitfile. Return False on any errors.</span>
<span class="sd">        Only run this once or the FPGA connection will fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Open the first device we find.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span> <span class="o">=</span> <span class="n">ok</span><span class="o">.</span><span class="n">okCFrontPanel</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">NoError</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">OpenBySerial</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A device could not be opened.  Is one connected?&quot;</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get some general information about the device.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span> <span class="o">=</span> <span class="n">ok</span><span class="o">.</span><span class="n">okTDeviceInfo</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">NoError</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">GetDeviceInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve device information.&quot;</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;         Product: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">productName</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Firmware version: </span><span class="si">%d</span><span class="s2">.</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">deviceMajorVersion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">deviceMinorVersion</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Serial Number: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">serialNumber</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;       Device ID: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">deviceID</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;       USB Speed  </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_info</span><span class="o">.</span><span class="n">usbSpeed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">LoadDefaultPLLConfiguration</span><span class="p">()</span>

        <span class="c1"># Download the configuration file.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">NoError</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ConfigureFPGA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitfile</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FPGA configuration failed.&quot;</span><span class="p">)</span>
                <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loaded bit-file: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bitfile</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Skipped bit-file update&#39;</span><span class="p">)</span>

        <span class="c1"># Check for FrontPanel support in the FPGA configuration.</span>
        <span class="k">if</span> <span class="p">(</span><span class="kc">False</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsFrontPanelEnabled</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FrontPanel support is not available.&quot;</span><span class="p">)</span>
            <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FrontPanel support is available.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="FPGA.read_pipe_out"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.read_pipe_out">[docs]</a>    <span class="k">def</span> <span class="nf">read_pipe_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data_len</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the filled buffer and error code after reading an OK PipeOut.</span>
<span class="sd">            data_len is length in bytes (must be multiple of 16)</span>
<span class="sd">            returns: bytearray; error code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data_len</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ReadFromPipeOut</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="c1"># print(&#39;read_pipe_out:&#39;, addr, buf)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error code </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">,</span> <span class="n">e</span></div>

<div class="viewcode-block" id="FPGA.set_wire"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.set_wire">[docs]</a>    <span class="k">def</span> <span class="nf">set_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mh">0xFFFFFFFF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the error code after setting an OK WireIn value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;set_wire(address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">, value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">, mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">error_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">error_code</span></div>

<div class="viewcode-block" id="FPGA.read_wire"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.read_wire">[docs]</a>    <span class="k">def</span> <span class="nf">read_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the read data after reading an OK WireOut.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireOuts</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">GetWireOutValue</span><span class="p">(</span><span class="n">address</span><span class="p">)</span></div>

<div class="viewcode-block" id="FPGA.set_endpoint"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.set_endpoint">[docs]</a>    <span class="k">def</span> <span class="nf">set_endpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all bits in an Endpoint high.&quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;set_endpoint(address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">, value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s1">, mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span></div>

<div class="viewcode-block" id="FPGA.clear_endpoint"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.clear_endpoint">[docs]</a>    <span class="k">def</span> <span class="nf">clear_endpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set all bits in an Endpoint low.&quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;clear_endpoint(address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">, value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s1">, mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># clear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span></div>

<div class="viewcode-block" id="FPGA.toggle_low"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.toggle_low">[docs]</a>    <span class="k">def</span> <span class="nf">toggle_low</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Toggle all bits in an Endpoint low then back to high.&quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span>
            <span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># toggle low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>   <span class="c1"># back high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span></div>

<div class="viewcode-block" id="FPGA.toggle_high"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.toggle_high">[docs]</a>    <span class="k">def</span> <span class="nf">toggle_high</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Toggle all bits in an Endpoint high then back to low.&quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># toggle high</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>   <span class="c1"># back low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span></div>

<div class="viewcode-block" id="FPGA.send_trig"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.send_trig">[docs]</a>    <span class="k">def</span> <span class="nf">send_trig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the error code after activating an OK TriggerIn Endpoint.</span>

<span class="sd">        Expects a single bit, not yet implement for multiple bits and will only</span>
<span class="sd">        activate the LSB if the Endpoint containts multiple bits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># print(f&#39;send_trig(address={hex(ep_bit.address)},bit={ep_bit.bit_index_low})&#39;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="FPGA.read_trig"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.read_trig">[docs]</a>    <span class="k">def</span> <span class="nf">read_trig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read an OK TriggerOut Endpoint.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ep_bit : Endpoint</span>
<span class="sd">            The endpoint containing the bit_index_low and address of the</span>
<span class="sd">            TriggerOut to read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether the TriggerOut has been triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsTriggered</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ep_bit</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">))</span></div>

<div class="viewcode-block" id="FPGA.read_ep"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.read_ep">[docs]</a>    <span class="k">def</span> <span class="nf">read_ep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep_bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the error code after reading an OK WireOut Endpoint.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireOuts</span><span class="p">()</span>
        <span class="n">read_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">GetWireOutValue</span><span class="p">(</span><span class="n">ep_bit</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">read_out</span></div>

<div class="viewcode-block" id="FPGA.set_wire_bit"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.set_wire_bit">[docs]</a>    <span class="k">def</span> <span class="nf">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a single bit to 1 in a OpalKelly wire in.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;set_wire_bit(address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">,value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span><span class="si">}</span><span class="s1">,mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span></div>

<div class="viewcode-block" id="FPGA.clear_wire_bit"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.clear_wire_bit">[docs]</a>    <span class="k">def</span> <span class="nf">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear a single bit to 0 in a OpalKelly wire in.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;clear_wire_bit(address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">,value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span><span class="si">}</span><span class="s1">,mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span></div>

<div class="viewcode-block" id="FPGA.set_ep_simultaneous"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.set_ep_simultaneous">[docs]</a>    <span class="k">def</span> <span class="nf">set_ep_simultaneous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">bit_list</span><span class="p">,</span> <span class="n">val_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; set multiple values to the wire of a single endpoint&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bit</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bit_list</span><span class="p">,</span> <span class="n">val_list</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Simultaneous wire write (address=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s1">,value=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">,mask=</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="FPGA.read_wire_bit"><a class="viewcode-back" href="../../FPGA.html#interfaces.interfaces.FPGA.read_wire_bit">[docs]</a>    <span class="k">def</span> <span class="nf">read_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a single bit in a OpalKelly wire in.&quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span></div></div>


<div class="viewcode-block" id="I2CController"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController">[docs]</a><span class="k">class</span> <span class="nc">I2CController</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for controllers on the FPGA using I2C protocol.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    I2C_MAX_TIMEOUT_MS : int</span>
<span class="sd">        Maximum wait time until transmission timeout in milliseconds.</span>
<span class="sd">    i2c : dict</span>
<span class="sd">        Dictionary of I2C memory buffer and data start location.</span>
<span class="sd">    fpga : FPGA</span>
<span class="sd">        FPGA instance this controller uses to communicate.</span>
<span class="sd">    endpoints : dict</span>
<span class="sd">        Endpoints on the FPGA this controller uses to communicate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">I2C_MAX_TIMEOUT_MS</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">addr_pins</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">,</span> <span class="n">i2c</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;m_nDataStart&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span> <span class="o">=</span> <span class="n">i2c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span> <span class="o">=</span> <span class="n">fpga</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">=</span> <span class="n">addr_pins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>

<div class="viewcode-block" id="I2CController.create_chips"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.create_chips">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_chips</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">addr_pins</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a number of new I2C chips.</span>

<span class="sd">        The FPGA and endpoints will be the same for all instantiated chips.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fpga : FPGA</span>
<span class="sd">            The fpga instance for the chip to connect with.</span>
<span class="sd">        addr_pins : list</span>
<span class="sd">            The list of addr_pins assigned to the new chips.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of the newly instantiated chips in the same order addr_pins was given in.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="bp">cls</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">addr_pins</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">)</span> <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">addr_pins</span><span class="p">]</span></div>


    <span class="c1"># STARTS - Defines the preamble bytes after which a start bit is</span>
    <span class="c1">#      transmitted. For example, if STARTS=0x04, a start bit is</span>
    <span class="c1">#      transmitted after the 3rd preamble byte.</span>
    <span class="c1"># STOPS - Defines the preamble bytes after which a stop bit is</span>
    <span class="c1">#      transmitted. For example, if STOPS=0x04, a stop bit is</span>
    <span class="c1">#      transmitted after the 3rd preamble byte.</span>
    <span class="c1"># LENGTH - Length of the preamble in bytes.</span>
    <span class="c1">#</span>
    <span class="c1"># Note: If there is a one in the same position for both STARTS and STOPS,</span>
    <span class="c1">#       the stop takes precedence.</span>

    <span class="c1"># The preamble is the device address, byte address, and (if a read) device address again:</span>
    <span class="c1">#   preamble[0] = 0xA0; // devAddr (write)</span>
    <span class="c1">#   preamble[1] = 0x00; // byteAddress (MSB)</span>
    <span class="c1">#   preamble[2] = 0x00; // byteAddress (LSB)</span>
    <span class="c1">#   preamble[3] = 0xA1; // devAddr (read)</span>

    <span class="c1"># from the HDL</span>

<div class="viewcode-block" id="I2CController.i2c_configure"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.i2c_configure">[docs]</a>    <span class="k">def</span> <span class="nf">i2c_configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">preamble_length</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">,</span> <span class="n">preamble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the buffer for the next transmission.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">preamble_length</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Preamble data is too long&#39;</span><span class="p">)</span> 
            <span class="c1"># throw DataTooLongException();</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="n">preamble_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">preamble_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">starts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stops</span>
        <span class="c1"># Payload length will be provided later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">preamble_length</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">preamble</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_nDataStart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">preamble_length</span></div>

<div class="viewcode-block" id="I2CController.i2c_transmit"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.i2c_transmit">[docs]</a>    <span class="k">def</span> <span class="nf">i2c_transmit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Send data along the SCL and SDA lines.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_length</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_length</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Reset the memory pointer and transfer the buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_nDataStart&#39;</span><span class="p">]):</span>  
            <span class="c1"># print(&#39;(transmit) WireIn Value = {}&#39;.format(self.i2c[&#39;m_pBuf&#39;][i]))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMWRITE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMWRITE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="c1"># Start I2C transaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="c1"># Wait for transaction to finish</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">I2CController</span><span class="o">.</span><span class="n">I2C_MAX_TIMEOUT_MS</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>
            <span class="c1"># change to waiting for True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsTriggered</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DONE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DONE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Timeout error in transmit&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="I2CController.i2c_receive"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.i2c_receive">[docs]</a>    <span class="k">def</span> <span class="nf">i2c_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_length</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="s1">&#39;wire&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take in data from the SCL and SDA lines.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_length</span>

        <span class="c1"># Reset the memory pointer and transfer the buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_nDataStart&#39;</span><span class="p">]):</span>
            <span class="c1"># print(&#39;WireIn Value = {}&#39;.format(self.i2c[&#39;m_pBuf&#39;][i]))</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c</span><span class="p">[</span><span class="s1">&#39;m_pBuf&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">SetWireInValue</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireIns</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMWRITE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMWRITE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="c1"># Start I2C transaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;START&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="c1"># Wait for transaction to finish</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">I2CController</span><span class="o">.</span><span class="n">I2C_MAX_TIMEOUT_MS</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsTriggered</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DONE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                         <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DONE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;wire&#39;</span><span class="p">:</span>
                    <span class="c1"># Read data: Reset the memory pointer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMSTART&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">data_length</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_length</span><span class="p">):</span>  <span class="c1"># for each byte we have three API calls </span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateWireOuts</span><span class="p">()</span>
                        <span class="n">data_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">GetWireOutValue</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_tmp</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMREAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMREAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">data</span>
                <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;pipe&#39;</span><span class="p">:</span>
                    <span class="c1"># should not be used. OK pipe is not configured.</span>
                    <span class="n">data_read</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data_length</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">16</span><span class="p">)</span><span class="o">*</span><span class="mi">16</span><span class="p">)</span>
                    <span class="n">buf</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pipe_out</span><span class="p">(</span><span class="mh">0xA0</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data_read</span><span class="p">)</span>
                    <span class="c1"># reset FIFO</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMREAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MEMREAD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
                    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="n">data_length</span><span class="p">]</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Timeout Exception in Rx&#39;</span><span class="p">)</span></div>

    <span class="c1"># def i2c_write8(self, devAddr, regAddr, data_length, data):</span>

    <span class="c1">#     preamble = [devAddr &amp; 0xfe, regAddr]</span>
    <span class="c1">#     self.i2c_configure(2, 0x00, 0x00, preamble)</span>
    <span class="c1">#     return self.i2c_transmit(data, data_length)</span>

<div class="viewcode-block" id="I2CController.i2c_write_long"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.i2c_write_long">[docs]</a>    <span class="k">def</span> <span class="nf">i2c_write_long</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">devAddr</span><span class="p">,</span> <span class="n">regAddr</span><span class="p">,</span> <span class="n">data_length</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Send a write command with given data to regAddr on devAddr.</span>

<span class="sd">        regAddr must be given in a list.&quot;&quot;&quot;</span>

        <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">devAddr</span> <span class="o">&amp;</span> <span class="mh">0xfe</span><span class="p">]</span> <span class="o">+</span> <span class="n">regAddr</span>  <span class="c1"># + data</span>
        <span class="c1"># def i2c_configure(self, data_length, starts, stops, preamble)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_configure</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">preamble</span><span class="p">),</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">preamble</span><span class="p">),</span> <span class="n">preamble</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_transmit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_length</span><span class="p">)</span></div>

    <span class="c1"># Sequence is</span>
    <span class="c1"># [START] DEV_ADDR(W) REG_ADDR [START] DEV_ADDR(R) VALUE</span>
    <span class="c1"># LJK - this command does not execute OK API calls</span>
    <span class="c1"># def i2c_read8(self, devAddr, regAddr, data_length):</span>

    <span class="c1">#     # for the pressure sensors that only need the slave address and a read bit and then send out 4 bytes.</span>
    <span class="c1">#     if regAddr is None:</span>
    <span class="c1">#         preamble = [devAddr | 0x01]</span>
    <span class="c1">#         self.i2c_configure(1, 0x01, 0x00, preamble)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         preamble = [devAddr &amp; 0xfe, regAddr, devAddr | 0x01]</span>
    <span class="c1">#         # signature: i2c_configure(data_length, starts (a one for each byte that gets a start), stops, preamble):</span>
    <span class="c1">#         self.i2c_configure(3, 0x02, 0x00, preamble)</span>
    <span class="c1">#     data = self.i2c_receive(data_length)</span>

    <span class="c1">#     return data</span>

    <span class="c1"># Sequence is</span>
    <span class="c1"># [START] DEV_ADDR(W) REG_ADDR [START] DEV_ADDR(R) VALUE</span>
    <span class="c1"># LJK - this command does not execute OK API calls</span>
<div class="viewcode-block" id="I2CController.i2c_read_long"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.i2c_read_long">[docs]</a>    <span class="k">def</span> <span class="nf">i2c_read_long</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">devAddr</span><span class="p">,</span> <span class="n">regAddr</span><span class="p">,</span> <span class="n">data_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read data_length bytes from regAddr on devAddr.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        devAddr : int</span>
<span class="sd">            8 bit address (don&#39;t set the read bit (LSB) since this is done in this function)</span>
<span class="sd">        regAddr : int</span>
<span class="sd">            Written to device (this is a list and must be even if length 1)</span>
<span class="sd">        data_length : int</span>
<span class="sd">            Number of bytes expected to receive</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">devAddr</span> <span class="o">&amp;</span> <span class="mh">0xfe</span><span class="p">]</span> <span class="o">+</span> <span class="n">regAddr</span> <span class="o">+</span> <span class="p">[</span><span class="n">devAddr</span> <span class="o">|</span> <span class="mh">0x01</span><span class="p">]</span>
        <span class="c1"># signature: i2c_configure(data_length, starts (a one for each byte that gets a start), stops, preamble):</span>
        <span class="n">start_positions</span> <span class="o">=</span> <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">regAddr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_configure</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">preamble</span><span class="p">),</span> <span class="n">start_positions</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">preamble</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_receive</span><span class="p">(</span><span class="n">data_length</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="I2CController.reset_device"><a class="viewcode-back" href="../../I2CController.html#interfaces.interfaces.I2CController.reset_device">[docs]</a>    <span class="k">def</span> <span class="nf">reset_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the I2C controller using an OK TriggerIn.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">TCA9555</span><span class="p">(</span><span class="n">I2CController</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for the I/O Expander TCA9555.</span>

<span class="sd">    Subclass of the I2CController class. Attributes and methods below are</span>
<span class="sd">    differences in this class from I2CController only.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ADDRESS_HEADER : int</span>
<span class="sd">        7-bit device address with R/W bit space and 4 MSBs filled in specific</span>
<span class="sd">        to this chip. The rest is left as 0 to be filled in later.</span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the TCA9555 chip.</span>
<span class="sd">    addr_pins : int</span>
<span class="sd">        3 LSBs of the 7-bit device address formed alongside the address header</span>
<span class="sd">        used to differentiate between different instances of the TCA9555 chip.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ADDRESS_HEADER</span> <span class="o">=</span> <span class="mb">0b0100_0000</span>
    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;TCA9555&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure_pins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the chip&#39;s pins as inputs (1&#39;s) or outputs (0&#39;s).&quot;&quot;&quot;</span>

        <span class="c1"># Inputs = 1</span>
        <span class="c1"># Outputs = 0</span>
        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">TCA9555</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CONFIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">register_name</span><span class="o">=</span><span class="s1">&#39;OUTPUT&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mh">0xffff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write 2 bytes of data to the pins.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compare with current data to mask unchanged values</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">read_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">current_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">read_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">current_data</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Read for masking FAILED&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">current_data</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Turn data into a list of bytes for i2c_write method</span>
        <span class="n">list_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_data</span> <span class="o">//</span> <span class="p">(</span><span class="mi">16</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">new_data</span> <span class="o">%</span> <span class="p">(</span><span class="mi">16</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">TCA9555</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">list_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register_name</span><span class="o">=</span><span class="s1">&#39;INPUT&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read 2 bytes of data from the pins.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mb">0b1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">TCA9555</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UID_24AA025UID</span><span class="p">(</span><span class="n">I2CController</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for the ID chip 24AA025UID.</span>

<span class="sd">    Subclass of the I2CController class. Attributes and methods below are</span>
<span class="sd">    differences in this class from I2CController only.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ADDRESS_HEADER : int</span>
<span class="sd">        7-bit device address with R/W bit space and 4 MSBs filled in specific</span>
<span class="sd">        to this chip. The rest is left as 0 to be filled in later.</span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the TCA9555 chip.</span>
<span class="sd">    addr_pins : int</span>
<span class="sd">        3 LSBs of the 7-bit device address formed alongside the address header</span>
<span class="sd">        used to differentiate between different instances of the TCA9555 chip.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ADDRESS_HEADER</span> <span class="o">=</span> <span class="mb">0b10100000</span>
    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;24AA025UID&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">word_address</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">num_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write data into memory at word_address.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">UID_24AA025UID</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;word_address: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">word_address</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">data: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">num_bytes: </span><span class="si">{</span><span class="n">num_bytes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Convert data into a list</span>
        <span class="k">if</span> <span class="n">num_bytes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># User did not specify a number of bytes</span>
            <span class="n">list_data</span> <span class="o">=</span> <span class="n">int_to_list</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="n">num_bytes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># User specified a number of bytes</span>
            <span class="n">list_data</span> <span class="o">=</span> <span class="n">int_to_list</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">num_bytes</span><span class="o">=</span><span class="n">num_bytes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">list_data</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># int_to_list returns False when the data is longer than the number of bytes</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: data exceeds given number of bytes&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>
            <span class="c1"># After 16 bytes (1 page), the UID chip will rollover and overwrite data from ealier.</span>
            <span class="c1"># To fix this, we start a new I2C write command at the next page</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span><span class="n">devAddr</span><span class="o">=</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">regAddr</span><span class="o">=</span><span class="p">[</span>
                                <span class="n">word_address</span><span class="p">],</span> <span class="n">data_length</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">list_data</span><span class="p">[:</span><span class="mi">16</span><span class="p">])</span>
            <span class="c1"># We can recursively call this function instead of looping through multiple times.</span>
            <span class="c1"># recurse_data = data % (0x1 &lt;&lt; (8 * (num_bytes - 16)))</span>
            <span class="n">recurse_data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
                <span class="n">recurse_data</span> <span class="o">-=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">recurse_data</span> <span class="o">&gt;&gt;=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">8</span>
            <span class="c1"># print(f&#39;{data} % {(0x1 &lt;&lt; (8 * (num_bytes - 16)))} = {recurse_data}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">recurse_data</span><span class="p">,</span> <span class="n">word_address</span><span class="o">=</span><span class="p">(</span><span class="n">word_address</span>
                       <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="mh">0x80</span><span class="p">,</span> <span class="n">num_bytes</span><span class="o">=</span><span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Data is no more than 16 bytes (1 page) and can be written with 1 I2C command.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span><span class="n">devAddr</span><span class="o">=</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">regAddr</span><span class="o">=</span><span class="p">[</span><span class="n">word_address</span><span class="p">],</span> <span class="n">data_length</span><span class="o">=</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">list_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_address</span><span class="o">=</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">words_read</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return words_read words of data from memory at word_address.&quot;&quot;&quot;</span>

        <span class="c1"># A word is a byte, 8 bits</span>
        <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">UID_24AA025UID</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mb">0b1</span>
        <span class="c1"># Bug when reading more than 64 bytes, only 128 bytes possible so check and split to 2 operations</span>
        <span class="k">if</span> <span class="n">words_read</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="n">d0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">word_address</span><span class="p">],</span> <span class="mi">64</span><span class="p">)</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">word_address</span> <span class="o">+</span> <span class="mi">64</span><span class="p">],</span> <span class="n">words_read</span> <span class="o">-</span> <span class="mi">64</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">d0</span> <span class="o">+</span> <span class="n">d1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">word_address</span><span class="p">],</span> <span class="n">words_read</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_serial_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the unique 32-serial number stored in memory on the chip.&quot;&quot;&quot;</span>

        <span class="n">serial_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
            <span class="n">word_address</span><span class="o">=</span><span class="n">UID_24AA025UID</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;SERIAL_NUMBER&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">words_read</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">serial_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">serial_list</span><span class="p">:</span>
            <span class="n">serial_number</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span>
            <span class="n">serial_number</span> <span class="o">|=</span> <span class="n">byte</span>

        <span class="k">return</span> <span class="n">serial_number</span>

    <span class="k">def</span> <span class="nf">get_manufacturer_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the chip&#39;s manufacturer code.</span>

<span class="sd">        For the chips we are using, it should be 0x29.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">word_address</span><span class="o">=</span><span class="n">UID_24AA025UID</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;MANUFACTURER_CODE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_device_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the chip&#39;s device code.</span>

<span class="sd">        For the chips we are using, it should be 0x41.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">word_address</span><span class="o">=</span><span class="n">UID_24AA025UID</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;DEVICE_CODE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">DAC53401</span><span class="p">(</span><span class="n">I2CController</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for the I2C DAC chip DAC53401.</span>

<span class="sd">    Subclass of the I2CController class. Attributes and methods below are</span>
<span class="sd">    differences in this class from I2CController only.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ADDRESS_HEADER : int</span>
<span class="sd">        7-bit device address with R/W bit space and 4 MSBs filled in specific</span>
<span class="sd">        to this chip. The rest is left as 0 to be filled in later.</span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the TCA9555 chip.</span>
<span class="sd">    addr_pins : int</span>
<span class="sd">        3 LSBs of the 7-bit device address formed alongside the address header</span>
<span class="sd">        used to differentiate between different instances of the TCA9555 chip.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ADDRESS_HEADER</span> <span class="o">=</span> <span class="mb">0b10010000</span>
    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;DAC53401&#39;</span><span class="p">)</span>

    <span class="c1">#        Address Pins Guide</span>
    <span class="c1"># Slave Address   |   A0 Pin</span>
    <span class="c1">#           000   |   AGND</span>
    <span class="c1">#           001   |   VDD</span>
    <span class="c1">#           010   |   SDA</span>
    <span class="c1">#           011   |   SCL</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">register_name</span><span class="o">=</span><span class="s1">&#39;DAC_DATA&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write data to any register on the chip.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">register</span> <span class="o">=</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span>

        <span class="c1"># Mask only the bits for the specified register.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">,</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span>

        <span class="c1"># Compare with current data to mask unchanged values</span>
        <span class="n">read_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">register_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">read_out</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Read for masking FAILED&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_out</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Turn data into a list of bytes for i2c_write method</span>
        <span class="c1"># Essentially round up to the closest byte</span>
        <span class="c1">#number_of_bytes = (register.bit_width + 7) // 8</span>
        <span class="n">list_data</span> <span class="o">=</span> <span class="n">int_to_list</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">number_of_bytes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">register</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="n">number_of_bytes</span><span class="p">,</span> <span class="n">list_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register_name</span><span class="o">=</span><span class="s1">&#39;DAC_DATA&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data from any register on the chip.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">ADDRESS_HEADER</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">addr_pins</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">register</span> <span class="o">=</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span>
        <span class="c1"># Ex. 16-bit register: | Byte 1 [15:8] | Byte 0 [7:0] |</span>
        <span class="n">byte_number</span> <span class="o">=</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">//</span> <span class="mi">8</span>
        <span class="c1"># 16-bit register = 2 bytes, i2c_read_long starts at the MSB so we read 2 bytes to get Byte 0</span>
        <span class="n">number_of_bytes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">byte_number</span>
        <span class="n">read_back_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">register</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="n">number_of_bytes</span><span class="p">)</span>

        <span class="c1"># Turn the list into an integer</span>
        <span class="n">read_back_data</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">read_back_list</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># First byte in the list is the MSB, shift and append the next byte</span>
        <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">read_back_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Readback byte of </span><span class="si">{:02X}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">byte</span><span class="p">))</span>
            <span class="n">read_back_data</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span>
            <span class="n">read_back_data</span> <span class="o">|=</span> <span class="n">byte</span>
        <span class="c1"># Get only the bits for the specified register from what was read back.</span>
        <span class="n">desired_bits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">,</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">desired_bits</span> <span class="o">+=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span>
        <span class="n">desired_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_back_data</span>
                        <span class="o">&amp;</span> <span class="n">desired_bits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span>

        <span class="k">return</span> <span class="n">desired_data</span>

    <span class="k">def</span> <span class="nf">write_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voltage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a voltage output from the DAC.&quot;&quot;&quot;</span>

        <span class="n">voltage_data</span> <span class="o">=</span> <span class="n">from_voltage</span><span class="p">(</span><span class="n">voltage</span><span class="o">=</span><span class="n">voltage</span><span class="p">,</span> <span class="n">num_bits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">voltage_range</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">with_negatives</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">voltage_data</span><span class="p">,</span> <span class="s1">&#39;DAC_DATA&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enable_internal_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable the DAC&#39;s internal reference.</span>

<span class="sd">        This is necessary to set the gain value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="s1">&#39;REF_EN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the DAC&#39;s output gain value.</span>

<span class="sd">        Gain can be set to 1.5x, 2x, 3x, or 4x the internal reference.</span>
<span class="sd">        Internal reference must be enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gain_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mf">1.5</span><span class="p">:</span> <span class="mb">0b00</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="mb">0b01</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="mb">0b10</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="mb">0b11</span>
        <span class="p">}</span>

        <span class="n">gain_code</span> <span class="o">=</span> <span class="n">gain_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gain</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gain_code</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid gain&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">gain_code</span><span class="p">,</span> <span class="s1">&#39;DAC_SPAN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DAC&#39;s current output gain value.&quot;&quot;&quot;</span>

        <span class="n">gain_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mb">0b00</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span>
            <span class="mb">0b01</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="mb">0b10</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="mb">0b11</span><span class="p">:</span> <span class="mi">4</span>
        <span class="p">}</span>

        <span class="n">gain_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;DAC_SPAN&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gain_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gain_code</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the function generator.</span>

<span class="sd">        &#39;triangle&#39;: Triangle wave between MARGIN_HIGH code to MARGIN_LOW code</span>
<span class="sd">            with slope defined by SLEW_RATE.</span>
<span class="sd">        &#39;sawtooth_falling&#39;: Saw-Tooth wave between MARGIN_HIGH code to</span>
<span class="sd">            MARGIN_LOW code with slope defined by SLEW_RATE and immeidate falling edge.</span>
<span class="sd">        &#39;sawtooth_rising&#39;: Saw-Tooth wave between MARGIN_HIGH code to</span>
<span class="sd">            MARGIN_LOW code with slope defined by SLEW_RATE and immeidate rising edge.</span>
<span class="sd">        &#39;square&#39;: Square wave between MARGIN_HIGH code to MARGIN_LOW code with</span>
<span class="sd">            pulse high and low period defined by defined by SLEW_RATE.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">func_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;triangle&#39;</span><span class="p">:</span> <span class="mb">0b00</span><span class="p">,</span>
            <span class="s1">&#39;sawtooth_falling&#39;</span><span class="p">:</span> <span class="mb">0b01</span><span class="p">,</span>
            <span class="s1">&#39;sawtooth_rising&#39;</span><span class="p">:</span> <span class="mb">0b10</span><span class="p">,</span>
            <span class="s1">&#39;square&#39;</span><span class="p">:</span> <span class="mb">0b11</span>
        <span class="p">}</span>

        <span class="n">func_code</span> <span class="o">=</span> <span class="n">func_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">function_name</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">func_code</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid function name&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">func_code</span><span class="p">,</span> <span class="s1">&#39;FUNC_CONFIG&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start function generation.</span>

<span class="sd">        Waveform configured through config_func() and config_margins() functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b1</span><span class="p">,</span> <span class="s1">&#39;START_FUNC_GEN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stop_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stop function generation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b0</span><span class="p">,</span> <span class="s1">&#39;START_FUNC_GEN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_margins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin_high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin_low</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure margin high and low values.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">margin_high</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">margin_high</span><span class="p">,</span> <span class="s1">&#39;MARGIN_HIGH&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">margin_low</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">margin_low</span><span class="p">,</span> <span class="s1">&#39;MARGIN_LOW&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the number of bits to step through.&quot;&quot;&quot;</span>

        <span class="n">step_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="mb">0b000</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="mb">0b001</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="mb">0b010</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="mb">0b011</span><span class="p">,</span>
            <span class="mi">6</span><span class="p">:</span> <span class="mb">0b100</span><span class="p">,</span>
            <span class="mi">8</span><span class="p">:</span> <span class="mb">0b101</span><span class="p">,</span>
            <span class="mi">16</span><span class="p">:</span> <span class="mb">0b110</span><span class="p">,</span>
            <span class="mi">32</span><span class="p">:</span> <span class="mb">0b111</span>
        <span class="p">}</span>

        <span class="n">step_code</span> <span class="o">=</span> <span class="n">step_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step_code</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid step&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">step_code</span><span class="p">,</span> <span class="s1">&#39;CODE_STEP&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">config_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the rate to step through each bit.&quot;&quot;&quot;</span>

        <span class="c1"># Instead of asking the user to type in the timing, the rates are organized slowest to fastest and numbered 1-16</span>
        <span class="n">rate_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="mb">0b1011</span><span class="p">,</span>  <span class="c1"># 1638.4 * 1.75 us</span>
            <span class="mi">2</span><span class="p">:</span> <span class="mb">0b1010</span><span class="p">,</span>  <span class="c1"># 1638.4 * 1.50 us</span>
            <span class="mi">3</span><span class="p">:</span> <span class="mb">0b1001</span><span class="p">,</span>  <span class="c1"># 1638.4 * 1.25 us</span>
            <span class="mi">4</span><span class="p">:</span> <span class="mb">0b1000</span><span class="p">,</span>  <span class="c1"># 1638.4        us</span>
            <span class="mi">5</span><span class="p">:</span> <span class="mb">0b0111</span><span class="p">,</span>  <span class="c1"># 204.8  * 1.75 us</span>
            <span class="mi">6</span><span class="p">:</span> <span class="mb">0b0110</span><span class="p">,</span>  <span class="c1"># 204.8  * 1.50 us</span>
            <span class="mi">7</span><span class="p">:</span> <span class="mb">0b0101</span><span class="p">,</span>  <span class="c1"># 204.8  * 1.25 us</span>
            <span class="mi">8</span><span class="p">:</span> <span class="mb">0b0100</span><span class="p">,</span>  <span class="c1"># 204.8         us</span>
            <span class="mi">9</span><span class="p">:</span> <span class="mb">0b0011</span><span class="p">,</span>  <span class="c1"># 25.6   * 1.75 us</span>
            <span class="mi">10</span><span class="p">:</span> <span class="mb">0b0010</span><span class="p">,</span>  <span class="c1"># 25.6   * 1.50 us</span>
            <span class="mi">11</span><span class="p">:</span> <span class="mb">0b0001</span><span class="p">,</span>  <span class="c1"># 25.6   * 1.25 us</span>
            <span class="mi">12</span><span class="p">:</span> <span class="mb">0b0000</span><span class="p">,</span>  <span class="c1"># 25.6          us</span>
            <span class="mi">13</span><span class="p">:</span> <span class="mb">0b1100</span><span class="p">,</span>  <span class="c1"># 12            us</span>
            <span class="mi">14</span><span class="p">:</span> <span class="mb">0b1101</span><span class="p">,</span>  <span class="c1"># 8             us</span>
            <span class="mi">15</span><span class="p">:</span> <span class="mb">0b1110</span><span class="p">,</span>  <span class="c1"># 4             us</span>
            <span class="mi">16</span><span class="p">:</span> <span class="mb">0b1111</span>  <span class="c1"># None</span>
        <span class="p">}</span>

        <span class="n">rate_code</span> <span class="o">=</span> <span class="n">rate_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rate_code</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid rate&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rate_code</span><span class="p">,</span> <span class="s1">&#39;SLEW_RATE&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the chip using a software reset.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b1010</span><span class="p">,</span> <span class="s1">&#39;SW_RESET&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lock the registers of the device so they cannot be changed.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b1</span><span class="p">,</span> <span class="s1">&#39;DEVICE_LOCK&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unlock the registers of the device so they can be changed again.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b0101</span><span class="p">,</span> <span class="s1">&#39;DEVICE_UNLOCK_CODE&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power up the DAC output.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b00</span><span class="p">,</span> <span class="s1">&#39;DAC_PDN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_down_10k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down the DAC output to 10K ohms.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b01</span><span class="p">,</span> <span class="s1">&#39;DAC_PDN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_down_high_impedance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down the DAC output to high impedance (default).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mb">0b10</span><span class="p">,</span> <span class="s1">&#39;DAC_PDN&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the device ID and version ID as one integer.&quot;&quot;&quot;</span>

        <span class="n">device_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;DEVICE_ID&#39;</span><span class="p">)</span>
        <span class="n">version_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;VERSION_ID&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">device_id</span> <span class="o">&lt;&lt;</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;DEVICE_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">version_id</span> <span class="o">&lt;&lt;</span> <span class="n">DAC53401</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;VERSION_ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>




<span class="k">class</span> <span class="nc">TMF8801</span><span class="p">(</span><span class="n">I2CController</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for the Time-of-flight I2C device</span>

<span class="sd">    Subclass of the I2CController class. Attributes and methods below are</span>
<span class="sd">    differences in this class from I2CController only.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ADDRESS : int</span>
<span class="sd">        7-bit device address with R/W bit space </span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the chip.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ADDRESS</span> <span class="o">=</span> <span class="mb">0b0100_0001</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;TMF8801&#39;</span><span class="p">)</span>
    <span class="n">apps</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;measure&#39;</span><span class="p">:</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="s1">&#39;bootloader&#39;</span><span class="p">:</span> <span class="mh">0x80</span><span class="p">}</span>


    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">register_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write data to any register on the chip.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span> 
        <span class="n">register</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">&lt;&lt;=</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span>

        <span class="c1"># Mask only the bits for the specified register.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">,</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span>

        <span class="c1"># Compare with current data to mask unchanged values</span>
        <span class="n">read_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">register_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">read_out</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Read for masking FAILED&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">read_out</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Turn data into a list of bytes for i2c_write method</span>
        <span class="n">list_data</span> <span class="o">=</span> <span class="n">int_to_list</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">number_of_bytes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_data</span><span class="p">)</span>
        <span class="n">list_data_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;0x</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">02x</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_data</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i2c write long: 0x</span><span class="si">{</span><span class="n">dev_addr</span><span class="si">:</span><span class="s1">02x</span><span class="si">}</span><span class="s1">, reg addr 0x</span><span class="si">{</span><span class="n">register</span><span class="o">.</span><span class="n">address</span><span class="si">:</span><span class="s1">02x</span><span class="si">}</span><span class="s1">, data </span><span class="si">{</span><span class="n">list_data_str</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">register</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="n">number_of_bytes</span><span class="p">,</span> <span class="n">list_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register_name</span><span class="p">,</span> <span class="n">number_of_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data from any register on the chip.&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span> 
        <span class="n">register</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">register_name</span><span class="p">]</span>
        <span class="c1"># Ex. 16-bit register: | Byte 1 [15:8] | Byte 0 [7:0] |</span>
        <span class="n">byte_number</span> <span class="o">=</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span> <span class="o">//</span> <span class="mi">8</span>  <span class="c1"># assumption is that this will be 1 or 0 </span>
        <span class="c1"># 16-bit register = 2 bytes, i2c_read_long starts at the MSB so we read 2 bytes to get Byte 0</span>
        <span class="k">if</span> <span class="n">number_of_bytes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">number_of_bytes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">byte_number</span>
        <span class="c1"># print(f&#39;Read slave address: 0x{dev_addr:02x}, reg addr 0x{register.address:02x}&#39;)</span>
        <span class="n">read_back_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span>
            <span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">register</span><span class="o">.</span><span class="n">address</span><span class="p">],</span> <span class="n">number_of_bytes</span><span class="p">)</span>

        <span class="c1"># Turn the list into an integer</span>
        <span class="n">read_back_data</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">read_back_list</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># First byte in the list is the MSB, shift and append the next byte</span>
        <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">read_back_list</span><span class="p">:</span>
            <span class="c1"># print(&#39;Readback byte of 0x{:02X}&#39;.format(byte))</span>
            <span class="n">read_back_data</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span>
            <span class="n">read_back_data</span> <span class="o">|=</span> <span class="n">byte</span>
        <span class="c1"># Get only the bits for the specified register from what was read back.</span>
        <span class="n">desired_bits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">register</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">,</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">desired_bits</span> <span class="o">+=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span>
        <span class="n">desired_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_back_data</span>
                        <span class="o">&amp;</span> <span class="n">desired_bits</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">register</span><span class="o">.</span><span class="n">bit_index_low</span>

        <span class="k">return</span> <span class="n">desired_data</span>

    <span class="k">def</span> <span class="nf">power_down_high_impedance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down the DAC output to high impedance (default).&quot;&quot;&quot;</span>

        <span class="k">pass</span>
        <span class="c1"># self.write(0b10, &#39;DAC_PDN&#39;)</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the device ID and rev ID as one integer.&quot;&quot;&quot;</span>

        <span class="n">device_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
        <span class="n">version_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;REVID&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">device_id</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">version_id</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">cpu_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;CPU_RESET&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cpu_ready</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;CPU_READY&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">load_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="o">=</span><span class="s1">&#39;measure&#39;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">app</span> <span class="o">==</span> <span class="s1">&#39;measure&#39;</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mh">0xC0</span>
        <span class="k">elif</span> <span class="n">app</span> <span class="o">==</span> <span class="s1">&#39;bootloader&#39;</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mh">0x80</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;APPREQID&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPID&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_app</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">appid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPID&#39;</span><span class="p">)</span>
        <span class="n">appname</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apps</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apps</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">appid</span><span class="p">)]</span>  
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;In app </span><span class="si">{</span><span class="n">appname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appid</span> 


    <span class="k">def</span> <span class="nf">rom_fw_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rev_major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPREV_MAJOR&#39;</span><span class="p">)</span>
        <span class="n">rev_minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPREV_MINOR&#39;</span><span class="p">)</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPREV_PATCH&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;major: </span><span class="si">{</span><span class="n">rev_major</span><span class="si">}</span><span class="s1">, minor: </span><span class="si">{</span><span class="n">rev_minor</span><span class="si">}</span><span class="s1">, patch: </span><span class="si">{</span><span class="n">patch</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rev_major</span><span class="p">,</span> <span class="n">rev_minor</span><span class="p">,</span> <span class="n">patch</span>

    <span class="k">def</span> <span class="nf">bl_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmd</span><span class="p">):</span>

        <span class="n">appid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;APPID&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">appid</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">apps</span><span class="p">[</span><span class="s1">&#39;bootloader&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cannot send boatloader command when in measure app&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="s1">&#39;ramremap_reset&#39;</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mh">0x11</span>
        <span class="k">elif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="s1">&#39;download_init&#39;</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mh">0x14</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;CMD_DATA7&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ram_write_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Host_Driver_Comm document suggests this reads back 3 bytes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;CMD_DATA7&#39;</span><span class="p">,</span> <span class="n">number_of_bytes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">download_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span>
        <span class="n">reg_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CMD_DATA7&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0xC1</span><span class="p">]</span> <span class="c1">#TODO: why 0x29 - specified by host driver comms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">reg_addr</span><span class="p">],</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">ramremap_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span>
        <span class="n">reg_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CMD_DATA7&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xEE</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i2c_write_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">reg_addr</span><span class="p">],</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_dist_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span>
        <span class="n">reg_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;DISTANCE_PEAK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>
        <span class="n">num_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;DISTANCE_PEAK&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_width</span><span class="o">//</span><span class="mi">8</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">reg_addr</span><span class="p">],</span>
            <span class="n">data_length</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; For correctly updating of these registers by TMF8801, an I²C block read starting from address 0x1D</span>
<span class="sd">        until 0x27 shall be done.</span>
<span class="sd">        0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27&quot;&quot;&quot;</span>

        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span>
        <span class="n">reg_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;STATUS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span>

        <span class="n">read_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">reg_addr</span><span class="p">],</span>
            <span class="n">data_length</span> <span class="o">=</span> <span class="mi">11</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;status&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;register_contents&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;tid&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s1">&#39;result_num&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s1">&#39;result_info&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                <span class="s1">&#39;dist_mm&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">),</span>
                <span class="s1">&#39;sys_clk&#39;</span><span class="p">:</span> <span class="n">read_data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">read_data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">vals</span><span class="p">,</span> <span class="n">read_data</span>


    <span class="k">def</span> <span class="nf">read_by_addr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_addr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">dev_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDRESS</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i2c_read_long</span><span class="p">(</span><span class="n">dev_addr</span><span class="p">,</span> <span class="p">[</span><span class="n">reg_addr</span><span class="p">],</span>
            <span class="n">data_length</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">factory_calibration</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform factory calibration and return 14 bytes of data</span>
<span class="sd">        See AN000597 -- Factor Calibration 8.1</span>

<span class="sd">        Calibration Environment: Device has to be in the final (correct) optical stack</span>
<span class="sd">        Clear glass (no smudge on the glass)</span>
<span class="sd">        No target in front of the device within 40 cm (see datasheet)</span>
<span class="sd">        Dark room or low ambient light</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Factory calibration: device should be in dark room with no objects within 40 cm&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">,</span> <span class="s1">&#39;COMMAND&#39;</span><span class="p">)</span> <span class="c1"># Command is register 0x10</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">cal_done</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cal_done</span> <span class="o">!=</span> <span class="mh">0x0A</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">):</span>
            <span class="n">cal_done</span> <span class="o">=</span> <span class="n">tof</span><span class="o">.</span><span class="n">TMF</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;REGISTER_CONTENTS&#39;</span><span class="p">)</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cal done 0x</span><span class="si">{</span><span class="n">cal_done</span><span class="si">:</span><span class="s1">02x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">cal_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_by_addr</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">num_bytes</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calibration data&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">cal_data</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cal_data</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cal_data</span> 

<div class="viewcode-block" id="SPIController"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController">[docs]</a><span class="k">class</span> <span class="nc">SPIController</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for controllers on the FPGA using SPI protocol.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    WB_SET_ADDRESS : int</span>
<span class="sd">        Set address command for the Wishbone.</span>
<span class="sd">    WB_WRITE : int</span>
<span class="sd">        Write command for the Wishbone.</span>
<span class="sd">    WB_READ : int</span>
<span class="sd">        Read command for the Wishbone.</span>
<span class="sd">    WB_CLK_FREQ : int</span>
<span class="sd">        Frequency of the clock the Wishbone runs on.</span>
<span class="sd">    fpga : FPGA</span>
<span class="sd">        FPGA instance this controller uses to communicate.</span>
<span class="sd">    endpoints : dict</span>
<span class="sd">        Endpoints on the FPGA this controller uses to communicate.</span>
<span class="sd">    master_config : int</span>
<span class="sd">        Value of the CTRL register in the Wishbone.</span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the Wishbone.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">WB_SET_ADDRESS</span> <span class="o">=</span> <span class="mh">0x80000000</span>  <span class="c1"># These 3 are from the SPI core manual</span>
    <span class="n">WB_WRITE</span> <span class="o">=</span> <span class="mh">0x40000000</span>
    <span class="n">WB_READ</span> <span class="o">=</span> <span class="mh">0x00000000</span>
    <span class="c1"># ACK=0x200000000</span>
    <span class="n">WB_CLK_FREQ</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># clk_sys = 200 MHz in the top_level_module.v comments</span>

    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;SPI&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="n">registers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CTRL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">default</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span> <span class="o">=</span> <span class="n">fpga</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">master_config</span> <span class="o">=</span> <span class="n">master_config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>

<div class="viewcode-block" id="SPIController.create_chips"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.create_chips">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_chips</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">number_of_chips</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a number of new chips.</span>

<span class="sd">        The number must be an integer greater than zero. The endpoints between</span>
<span class="sd">        each instance will be incremented. If the endpoints argument is left</span>
<span class="sd">        as None, then we will use copies of the endpoints_from_defines</span>
<span class="sd">        dictionary for the endpoints for each instance, and update that</span>
<span class="sd">        original dictionary when we increment the endpoints. This way, the</span>
<span class="sd">        endpoints there are ready for another instantiation if needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">number_of_chips</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number_of_chips must be an integer greater than 0&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">chips</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">master_config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use class default for master_config</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">chips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">))</span>
                <span class="c1"># Use deepcopy to keep the endpoints for different instances separate</span>
                <span class="n">endpoints</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">chips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                    <span class="n">endpoints</span><span class="p">),</span> <span class="n">master_config</span><span class="o">=</span><span class="n">master_config</span><span class="p">))</span>
                <span class="c1"># Use deepcopy to keep the endpoints for different instances separate</span>
                <span class="n">endpoints</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Increment shared endpoints dictionary</span>
            <span class="c1"># TODO: is there a better way to do this?</span>
            <span class="c1"># We need to get the shared endpoints in endpoints_from_defines to</span>
            <span class="c1"># increment and we only have the endpoints given to us in the</span>
            <span class="c1"># argument.</span>
            <span class="n">shared_full_eps</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span>
            <span class="n">shared_chip_eps</span> <span class="o">=</span> <span class="n">shared_full_eps</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">shared_full_eps</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">shared_full_eps</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">shared_chip_eps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Increment custom dictionary</span>
            <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">chips</span></div>

<div class="viewcode-block" id="SPIController.wb_send_cmd"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_send_cmd">[docs]</a>    <span class="k">def</span> <span class="nf">wb_send_cmd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Send a command to the Wishbone.</span>

<span class="sd">        Sent in 32 bits through the WbSignal_converter Verilog module tos</span>
<span class="sd">        reformat to 34 bits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># print(f&#39;wb_send_cmd: {hex(self.endpoints[&quot;WB_IN&quot;].address)}, {hex(command)}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WB_IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">)</span>
        <span class="c1"># DEBUG: temporary for logging DAC80508 test</span>
        <span class="c1"># print(f&#39;ActivateTriggerIn(address={hex(self.parameters[&quot;WB_CONVERT&quot;].address)}, index={hex(self.parameters[&quot;WB_CONVERT&quot;].bit_index_high)}&#39;)</span>

        <span class="c1"># allows for optional debug prints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">send_trig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WB_CONVERT&#39;</span><span class="p">])</span></div>
        <span class="c1">#self.fpga.xem.ActivateTriggerIn(</span>
        <span class="c1">#    self.endpoints[&#39;WB_CONVERT&#39;].address, self.endpoints[&#39;WB_CONVERT&#39;].bit_index_low)  # High and low bit indexes are the same for the trigger because it is 1 bit wide</span>

<div class="viewcode-block" id="SPIController.wb_is_ack"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_is_ack">[docs]</a>    <span class="k">def</span> <span class="nf">wb_is_ack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the Wishbone sent back a write acknowledge.&quot;&quot;&quot;</span>

        <span class="k">pass</span></div>
    <span class="c1">#     response = self.fpga.read_wire(self.endpoints[&#39;OUT&#39;].address)</span>
    <span class="c1">#     return response == SPIController.ACK</span>

<div class="viewcode-block" id="SPIController.wb_set_address"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_set_address">[docs]</a>    <span class="k">def</span> <span class="nf">wb_set_address</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the address of the register we interact with in the Wishbone.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_send_cmd</span><span class="p">(</span>
            <span class="n">SPIController</span><span class="o">.</span><span class="n">WB_SET_ADDRESS</span> <span class="o">|</span> <span class="p">(</span><span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">)</span>  <span class="c1"># TODO: comment here what the | 0x1 is for when I figure it out</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_is_ack</span><span class="p">()</span>  <span class="c1"># TODO: test if acknowledge actually comes back</span></div>

<div class="viewcode-block" id="SPIController.wb_write"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_write">[docs]</a>    <span class="k">def</span> <span class="nf">wb_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write up to 30 bytes of data to the currently selected register.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_send_cmd</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">WB_WRITE</span> <span class="o">|</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_is_ack</span><span class="p">()</span>  <span class="c1"># TODO: test if acknowledge actually comes back</span></div>

<div class="viewcode-block" id="SPIController.wb_read"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_read">[docs]</a>    <span class="k">def</span> <span class="nf">wb_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data stored in the currently selected register.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_send_cmd</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">WB_READ</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.wb_go"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.wb_go">[docs]</a>    <span class="k">def</span> <span class="nf">wb_go</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initiate a SPI transmission.</span>

<span class="sd">        Initiated by setting the GO_BSY bit of the CTRL register to  1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CTRL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="c1"># TODO: fix ack</span>
        <span class="c1"># if ack:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;CTRL&quot;: SUCCESS&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;CTRL&quot;: FAIL&#39;)</span>
        <span class="c1">#     return False</span>

        <span class="c1"># Use or so we do not overwrite the CTRL configuration, just the GO_BSY bit</span>
        <span class="n">busy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">master_config</span> <span class="o">|</span> <span class="p">(</span>
            <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;GO_BSY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="c1"># add mask or something to not reset entire CTRL register</span>
        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_write</span><span class="p">(</span><span class="n">busy</span><span class="p">)</span>
        <span class="c1"># TODO: fix ack</span>
        <span class="c1"># if ack:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set GO_BSY bit: SUCCESS&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set GO_BSY bit: FAIL&#39;)</span>
        <span class="c1">#     return False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SPIController.select_slave"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.select_slave">[docs]</a>    <span class="k">def</span> <span class="nf">select_slave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slave_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Selecting a slave device.</span>

<span class="sd">        Set the correspoinding bit in the Slave Select register to 1.&quot;&quot;&quot;</span>

        <span class="c1"># Set address to SS register</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;SS&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>

        <span class="c1"># Write slave address</span>
        <span class="c1"># Don&#39;t need to mask the write because we only select 1 slave device at a time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wb_write</span><span class="p">(</span><span class="n">slave_address</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.set_divider"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.set_divider">[docs]</a>    <span class="k">def</span> <span class="nf">set_divider</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divider</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of the Wishbone&#39;s DIVIDER register.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;DIVIDER&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wb_write</span><span class="p">(</span><span class="n">divider</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.set_frequency"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.set_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">set_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the frequency of SPI SCLK.</span>

<span class="sd">        Set the DIVIDER register of the Wishbone with the corresponding divider</span>
<span class="sd">        for the target frequency. Frequency must be given in MHz.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">divider</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">round</span><span class="p">((</span><span class="n">SPIController</span><span class="o">.</span><span class="n">WB_CLK_FREQ</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">frequency</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Make sure divider does not exceed 32 bits</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">divider</span><span class="p">,</span> <span class="mh">0xffff_ffff</span><span class="p">)</span>
        <span class="c1"># print(&#39;Set frequency. Divider value = {}&#39;.format(divider))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_divider</span><span class="p">(</span><span class="n">divider</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">divider</span></div>

<div class="viewcode-block" id="SPIController.write"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write data on the SPI lines.</span>

<span class="sd">        Register should be either 0, 1, 2, or 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set address to Tx register</span>
        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span>
            <span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;Tx&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">register</span><span class="p">)]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="c1"># TODO: fix ack</span>
        <span class="c1"># if ack:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;Tx{register}&quot;: SUCCESS&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;Tx{register}&quot;: FAIL&#39;)</span>
        <span class="c1">#     return False</span>

        <span class="c1"># Write data</span>
        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># TODO: fix ack</span>
        <span class="c1"># if ack:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Data write to &quot;Tx{register}&quot;: SUCCESS&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Data write to &quot;Tx{register}&quot;: FAIL&#39;)</span>
        <span class="c1">#     return False</span>

        <span class="c1"># Set GO_BSY bit</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_go</span><span class="p">()</span></div>

<div class="viewcode-block" id="SPIController.read"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data from the selected data receive register.</span>

<span class="sd">        Register should be 0, 1, 2, or 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set address to the Rx register Rx0, Rx1, Rx2, or Rx3</span>
        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span>
            <span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;Rx&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">register</span><span class="p">)]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>

        <span class="c1"># TODO: fix ack</span>
        <span class="c1"># if ack:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;Rx{register}&quot;: SUCCESS&#39;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if self.debug:</span>
        <span class="c1">#         print(f&#39;Set address to &quot;Rx{register}&quot;: FAIL&#39;)</span>
        <span class="c1">#     return False</span>

        <span class="c1"># Read data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_read</span><span class="p">()</span></div>

<div class="viewcode-block" id="SPIController.configure_master_bin"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.configure_master_bin">[docs]</a>    <span class="k">def</span> <span class="nf">configure_master_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of the Wishbone&#39;s CTRL register directly.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CTRL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wb_write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">master_config</span> <span class="o">=</span> <span class="n">data</span></div>

<div class="viewcode-block" id="SPIController.configure_master"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.configure_master">[docs]</a>    <span class="k">def</span> <span class="nf">configure_master</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ASS</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IE</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">LSB</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Tx_NEG</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Rx_NEG</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">CHAR_LEN</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the Wishbone&#39;s CTRL register using several parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ASS : bool or int</span>
<span class="sd">            Automatic Slave Select</span>
<span class="sd">        IE : bool or int</span>
<span class="sd">            Set interrupt output active after a transfer is finished</span>
<span class="sd">        LSB : bool or int</span>
<span class="sd">            Send LSB first</span>
<span class="sd">        Tx_NEG : bool or int</span>
<span class="sd">            Change output signal on falling edge of SCLK</span>
<span class="sd">        Rx_NEG : bool or int</span>
<span class="sd">            Latch input signal on falling edge of SCLK</span>
<span class="sd">        CHAR_LEN : bool or int</span>
<span class="sd">            Number of bits transmitted per transfer (up to 64).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ASS&#39;</span><span class="p">:</span> <span class="n">ASS</span><span class="p">,</span> <span class="s1">&#39;IE&#39;</span><span class="p">:</span> <span class="n">IE</span><span class="p">,</span> <span class="s1">&#39;LSB&#39;</span><span class="p">:</span> <span class="n">LSB</span><span class="p">,</span>
                  <span class="s1">&#39;Tx_NEG&#39;</span><span class="p">:</span> <span class="n">Tx_NEG</span><span class="p">,</span> <span class="s1">&#39;Rx_NEG&#39;</span><span class="p">:</span> <span class="n">Rx_NEG</span><span class="p">,</span> <span class="s1">&#39;CHAR_LEN&#39;</span><span class="p">:</span> <span class="n">CHAR_LEN</span><span class="p">}</span>

        <span class="n">configuration</span> <span class="o">=</span> <span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CTRL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">configuration</span> <span class="o">|=</span> <span class="p">(</span>
                <span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_master_bin</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.get_master_configuration"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.get_master_configuration">[docs]</a>    <span class="k">def</span> <span class="nf">get_master_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current configuration of CTRL register.</span>

<span class="sd">        Includes ASS, IO, LSB, Tx_NEG, Rx_NEG, CHAR_LEN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">wb_set_address</span><span class="p">(</span><span class="n">SPIController</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="s1">&#39;CTRL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">config_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wb_read</span><span class="p">()</span>
        <span class="c1">#TODO: convert to text data to show individual settings</span>
        <span class="c1"># return config</span>
        <span class="k">return</span> <span class="n">config_data</span></div>

<div class="viewcode-block" id="SPIController.reset_master"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.reset_master">[docs]</a>    <span class="k">def</span> <span class="nf">reset_master</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the Wishbone Master and SPI Core.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MASTER_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;MASTER_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.set_host_mode"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.set_host_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_host_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Configure SPI controller to be host driven.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_FPGA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_FPGA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIController.set_fpga_mode"><a class="viewcode-back" href="../../SPIController.html#interfaces.interfaces.SPIController.set_fpga_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_fpga_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Configure SPI controller to be host driven.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_FPGA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_FPGA&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SPIFifoDriven"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven">[docs]</a><span class="k">class</span> <span class="nc">SPIFifoDriven</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class for SPI controllers on the FPGA driven by a FIFO.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    default_data_mux : dict</span>
<span class="sd">        Class attribute. Default data_mux dictionary.</span>
<span class="sd">    fpga : FPGA</span>
<span class="sd">        FPGA instance this controller uses to communicate.</span>
<span class="sd">    endpoints : dict</span>
<span class="sd">        Endpoints on the FPGA this controller uses to communicate.</span>
<span class="sd">    master_config : int</span>
<span class="sd">        Value of the CTRL register in the Wishbone.</span>
<span class="sd">    data_mux: dict</span>
<span class="sd">        Name to select value dictionary for source data MUX.</span>
<span class="sd">    current_data_mux : str</span>
<span class="sd">        Name of the current MUX data source.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">default_data_mux</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;DDR&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;ads8686_chA&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;DDR_norepeat&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># does not send an update if the DDR data is the same. Reduces digital switching noise on the SPI bus</span>
        <span class="s1">&#39;ad7961_ch0&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch2&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch3&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">,</span> <span class="n">master_config</span><span class="p">,</span> <span class="n">data_mux</span><span class="o">=</span><span class="n">default_data_mux</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span> <span class="o">=</span> <span class="n">fpga</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">master_config</span> <span class="o">=</span> <span class="n">master_config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_mux</span> <span class="o">=</span> <span class="n">data_mux</span>
        <span class="c1"># Start with host to minimize unintentional commands from other sources on startup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_data_mux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data_mux</span><span class="p">(</span><span class="s1">&#39;host&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># &#39;host&#39; was not in data_mux dict</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: no &#39;host&#39; in data_mux dict&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="SPIFifoDriven.create_chips"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.create_chips">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_chips</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">number_of_chips</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a number of new chips.</span>

<span class="sd">        The number must be an integer greater than zero. The endpoints between</span>
<span class="sd">        each instance will be incremented. If the endpoints argument is left</span>
<span class="sd">        as None, then we will use copies of the endpoints_from_defines</span>
<span class="sd">        dictionary for the endpoints for each instance, and update that</span>
<span class="sd">        original dictionary when we increment the endpoints. This way, the</span>
<span class="sd">        endpoints there are ready for another instantiation if needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">number_of_chips</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number_of_chips must be an integer greater than 0&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">chips</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">master_config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use class default for master_config</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">chips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">))</span>
                <span class="c1"># Use deepcopy to keep the endpoints for different instances separate</span>
                <span class="n">endpoints</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">chips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                    <span class="n">endpoints</span><span class="p">),</span> <span class="n">master_config</span><span class="o">=</span><span class="n">master_config</span><span class="p">))</span>
                <span class="c1"># Use deepcopy to keep the endpoints for different instances separate</span>
                <span class="n">endpoints</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Increment shared endpoints dictionary</span>
            <span class="c1"># TODO: is there a better way to do this?</span>
            <span class="c1"># We need to get the shared endpoints in endpoints_from_defines to</span>
            <span class="c1"># increment and we only have the endpoints given to us in the</span>
            <span class="c1"># argument.</span>
            <span class="n">shared_full_eps</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span>
            <span class="n">shared_chip_eps</span> <span class="o">=</span> <span class="n">shared_full_eps</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">shared_full_eps</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span>
                    <span class="nb">list</span><span class="p">(</span><span class="n">shared_full_eps</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chips</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
                <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">shared_chip_eps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Increment custom dictionary</span>
            <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">chips</span></div>

<div class="viewcode-block" id="SPIFifoDriven.filter_select"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.filter_select">[docs]</a>    <span class="k">def</span> <span class="nf">filter_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set whether SPI data comes from filter (&#39;set&#39;) or direct (&#39;clear&#39;)</span>

<span class="sd">        Direct comes from the spi_fifo_driven data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FILTER_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FILTER_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s1">&#39;clear&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FILTER_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FILTER_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Incorrect operation: </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s1"> for filter select </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIFifoDriven.set_data_mux"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.set_data_mux">[docs]</a>    <span class="k">def</span> <span class="nf">set_data_mux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configure the MUX that routes data source to the SPI output.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : str</span>
<span class="sd">            See SPIFifoDriven.data_mux dict for options and conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">select_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_mux</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">select_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Set data mux failed, </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s1"> not available&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DATA_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DATA_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_mux</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
                <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DATA_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DATA_SEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                           <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_data_mux</span> <span class="o">=</span> <span class="n">source</span></div>

<div class="viewcode-block" id="SPIFifoDriven.set_clk_divider"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.set_clk_divider">[docs]</a>    <span class="k">def</span> <span class="nf">set_clk_divider</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divide_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set clock divider to configure rate of SPI updates.</span>

<span class="sd">        Tupdate = Tclk * divide_value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PERIOD_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PERIOD_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_high</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PERIOD_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                           <span class="n">divide_value</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PERIOD_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span>
                           <span class="n">mask</span><span class="p">)</span>

        <span class="c1"># resets the SPI state machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIFifoDriven.set_ctrl_reg"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.set_ctrl_reg">[docs]</a>    <span class="k">def</span> <span class="nf">set_ctrl_reg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configures the SPI Wishbone control register over the registerBridge.</span>

<span class="sd">        HDL default is ctrlValue = 16&#39;h3010 (initialized in the HDL)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> <span class="n">reg_value</span><span class="p">)</span>

        <span class="c1"># resets the SPI state machine -- needed since these registers are only</span>
        <span class="c1">#   programmed at startup of the state machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIFifoDriven.set_spi_sclk_divide"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.set_spi_sclk_divide">[docs]</a>    <span class="k">def</span> <span class="nf">set_spi_sclk_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">divide_value</span><span class="o">=</span><span class="mh">0x01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configures the SPI Wishbone clock divider register over the registerBridge.</span>

<span class="sd">        HDL default is 8&#39;h13 (initialized in the HDL)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sys_clk</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1"># in MHz</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SCLK predicted frequency </span><span class="si">{:.2f}</span><span class="s1"> [MHz]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">sys_clk</span><span class="o">/</span><span class="p">(</span><span class="n">divide_value</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">divide_value</span><span class="p">)</span>

        <span class="c1"># resets the SPI state machine -- needed since these WishBone</span>
        <span class="c1">#   registers are only programmed at startup of the state machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REG_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="SPIFifoDriven.write"><a class="viewcode-back" href="../../SPIFifoDriven.html#interfaces.interfaces.SPIFifoDriven.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Host write 24 bits of data to the chip over SPI.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_data_mux</span> <span class="o">!=</span> <span class="s1">&#39;host&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_mux</span><span class="p">(</span><span class="s1">&#39;host&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_WIRE_IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;HOST_TRIG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">DAC80508</span><span class="p">(</span><span class="n">SPIFifoDriven</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for SPI DAC chip DAC80508.</span>

<span class="sd">    Subclass of the SPIFifoDriven class. Listed methods do not include SPIFifoDriven methods.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    WRITE_OPERATION : int</span>
<span class="sd">        SPI data prefix for writing to the DAC.</span>
<span class="sd">    READ_OPERATION : int</span>
<span class="sd">        SPI data prefix for reading from the DAC.</span>
<span class="sd">    registers : dict</span>
<span class="sd">        Name-Register pairs for the internal registers of the DAC80508.</span>
<span class="sd">    data_mux : dict</span>
<span class="sd">        Matches data source names in the MUX to their select values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">default_data_mux</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;DDR&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s1">&#39;ads8686_chA&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;ads8686_chB&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># different for the AD5453</span>
        <span class="s1">&#39;ad7961_ch0&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch2&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s1">&#39;ad7961_ch3&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">WRITE_OPERATION</span> <span class="o">=</span> <span class="mh">0x000000</span>
    <span class="n">READ_OPERATION</span> <span class="o">=</span> <span class="mh">0x800000</span>

    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;DAC80508&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="mh">0x3218</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_mux</span><span class="o">=</span><span class="n">default_data_mux</span><span class="p">):</span>
        <span class="c1"># master_config=0x3218 Sets CHAR_LEN=24, Rx_NEG, ASS, IE</span>
        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">get_chip_endpoints</span><span class="p">(</span><span class="s1">&#39;DAC80508&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="n">master_config</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">data_mux</span><span class="o">=</span><span class="n">data_mux</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_data_mux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_mux</span><span class="p">(</span><span class="s1">&#39;host&#39;</span><span class="p">)</span>

    <span class="c1"># Method to write to any register on the chip.</span>
    <span class="k">def</span> <span class="nf">write_chip_reg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register_name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to any register on the chip.&quot;&quot;&quot;</span>

        <span class="c1"># .get instead of [brackets] because .get will return None if the register name is not in the dictionary</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="n">DAC80508</span><span class="o">.</span><span class="n">registers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">register_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reg</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">register_name</span><span class="si">}</span><span class="s1"> not in registers&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># 23=0 (write), [22:20]=000 (reserved), [19:16]=A[3:0] (reg address), [15:0]=D[15:0] (data)</span>
        <span class="n">transmission</span> <span class="o">=</span> <span class="n">DAC80508</span><span class="o">.</span><span class="n">WRITE_OPERATION</span> <span class="o">+</span> \
            <span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">transmission</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">voltage</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">auto_gain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the voltage to the outputs of the DAC.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        voltage : int or float</span>
<span class="sd">            The decimal voltage to write. This will be rounded to a</span>
<span class="sd">            representable binary value.</span>
<span class="sd">        ouptuts : int or list(int)</span>
<span class="sd">            The output or list of outputs to write the voltage to.</span>
<span class="sd">        auto_gain : bool</span>
<span class="sd">            True to automatically set the gain for the</span>
<span class="sd">            outputs, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">auto_gain</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">voltage</span> <span class="o">&lt;=</span> <span class="mf">1.25</span><span class="p">:</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">divide_reference</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">voltage</span> <span class="o">*=</span> <span class="mi">2</span>  <span class="c1"># Double voltage so we can write as if output unaffected</span>
            <span class="k">elif</span> <span class="n">voltage</span> <span class="o">&lt;=</span> <span class="mf">2.5</span><span class="p">:</span>
                <span class="c1"># *2 and /2 is recommended instead of *1 and /1</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">divide_reference</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Don&#39;t need to change the voltage here because it is in our expected range</span>
            <span class="k">elif</span> <span class="n">voltage</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">divide_reference</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">voltage</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># Halve voltage so we can write as if output unaffected</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: cannot write voltage </span><span class="si">{</span><span class="n">voltage</span><span class="si">}</span><span class="s1">V, max 5V&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_gain</span><span class="p">(</span><span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">outputs</span><span class="p">,</span>
                          <span class="n">divide_reference</span><span class="o">=</span><span class="n">divide_reference</span><span class="p">)</span>
            <span class="n">gain_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gain&#39;</span><span class="p">:</span> <span class="n">gain</span><span class="p">,</span> <span class="s1">&#39;divide_reference&#39;</span><span class="p">:</span> <span class="n">divide_reference</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_info</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">voltage_bin</span> <span class="o">=</span> <span class="n">from_voltage</span><span class="p">(</span>
            <span class="n">voltage</span><span class="o">=</span><span class="n">voltage</span><span class="p">,</span> <span class="n">num_bits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">voltage_range</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">with_negatives</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_chip_reg</span><span class="p">(</span><span class="s1">&#39;DAC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">output</span><span class="p">),</span> <span class="n">voltage_bin</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_chip_reg</span><span class="p">(</span><span class="s1">&#39;DAC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">outputs</span><span class="p">),</span> <span class="n">voltage_bin</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gain_info</span>

    <span class="k">def</span> <span class="nf">set_config_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the configuration register with a binary number.&quot;&quot;&quot;</span>

        <span class="c1"># Write new config</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_chip_reg</span><span class="p">(</span><span class="s1">&#39;CONFIG&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ALM_SEL</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ALM_EN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">CRC_EN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">FSDO</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DSDO</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">REF_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC7_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC6_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC5_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC4_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC3_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC2_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC1_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">DAC0_PWDWN</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the configuration register using keyword arguments.&quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">ALM_SEL</span><span class="p">,</span> <span class="n">ALM_EN</span><span class="p">,</span> <span class="n">CRC_EN</span><span class="p">,</span> <span class="n">FSDO</span><span class="p">,</span>
                  <span class="n">DSDO</span><span class="p">,</span> <span class="n">REF_PWDWN</span><span class="p">,</span> <span class="n">DAC7_PWDWN</span><span class="p">,</span> <span class="n">DAC6_PWDWN</span><span class="p">,</span> <span class="n">DAC5_PWDWN</span><span class="p">,</span> <span class="n">DAC4_PWDWN</span><span class="p">,</span> <span class="n">DAC3_PWDWN</span><span class="p">,</span> <span class="n">DAC2_PWDWN</span><span class="p">,</span> <span class="n">DAC1_PWDWN</span><span class="p">,</span> <span class="n">DAC0_PWDWN</span><span class="p">]</span>

        <span class="c1"># TODO: is this right?</span>
        <span class="n">bit</span> <span class="o">=</span> <span class="mi">13</span>
        <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">bit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config_bin</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_gain_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the gain register with a binary value.</span>

<span class="sd">        1 gives a gain of 2 for the output at that bit index (0-7). 0 gives a</span>
<span class="sd">        gain of 1.</span>
<span class="sd">        The 8th bit from the right is the REFDIV-EN: 1 divides the</span>
<span class="sd">        internal reference voltage by 2. 0 leaves the reference voltage</span>
<span class="sd">        unaffected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_chip_reg</span><span class="p">(</span><span class="s1">&#39;GAIN&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">divide_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the output gain (x1 or x2) and reference divider (VREF=2.5 V).</span>
<span class="sd">            Suggested settings are: </span>
<span class="sd">            gain = 2, div_ref = /2 </span>
<span class="sd">            gain = 2, div_ref = /1</span>
<span class="sd">            gain = 1, div_ref = /1 (not recommended)</span>
<span class="sd">            gain = 1, div_ref = /2 </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain : int</span>
<span class="sd">            The gain for the outputs. 1 or 2.</span>
<span class="sd">        ouptuts : int or list(int)</span>
<span class="sd">            The output or list of outputs to set the gain for.</span>
<span class="sd">        divide_reference : bool</span>
<span class="sd">            True to divide the reference voltage by 2, False to leave the it</span>
<span class="sd">            unaffected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The reference divider bit is the 8th bit from the LSB in the gain</span>
        <span class="c1"># register. Output gain 0 is 0 bits in, output gain 1 1 bit in, etc.</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gain</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: gain value must be 1 or 2. Got </span><span class="si">{</span><span class="n">gain</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">gain_bin</span> <span class="o">=</span> <span class="n">divide_reference</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="n">gain_bin</span> <span class="o">|=</span> <span class="p">(</span><span class="n">gain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">output</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">gain_bin</span> <span class="o">|=</span> <span class="p">(</span><span class="n">gain</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gain_bin</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gain_bin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Soft reset the chip.&quot;&quot;&quot;</span>

        <span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_chip_reg</span><span class="p">(</span><span class="s1">&#39;TRIGGER&#39;</span><span class="p">,</span> <span class="mb">0b1010</span><span class="p">,</span> <span class="mh">0x000f</span><span class="p">)</span>
        <span class="c1"># if self.debug:</span>
        <span class="c1">#     if ack:</span>
        <span class="c1">#         print(&#39;Reset: SUCCESS&#39;)</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         print(&#39;Reset: FAIL&#39;)</span>
        <span class="c1"># return ack</span>


<span class="k">class</span> <span class="nc">AD5453</span><span class="p">(</span><span class="n">SPIFifoDriven</span><span class="p">):</span>
    <span class="c1"># TODO: add class docstring</span>

    <span class="n">bits</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">vref</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">*</span><span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="mh">0x3010</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_mux</span><span class="o">=</span><span class="n">SPIFifoDriven</span><span class="o">.</span><span class="n">default_data_mux</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">get_chip_endpoints</span><span class="p">(</span><span class="s1">&#39;AD5453&#39;</span><span class="p">)</span>

        <span class="c1"># master_config=0x3010 Sets CHAR_LEN=16, ASS, IE</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="n">master_config</span><span class="p">,</span>
                         <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">data_mux</span><span class="o">=</span><span class="n">data_mux</span><span class="p">)</span>
        <span class="c1"># Default to clocking data into the shift register on the falling edge of the clock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clk_edge_bits</span> <span class="o">=</span> <span class="mb">0b00</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mh">0x009e1586</span><span class="p">,</span>
                             <span class="mi">1</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                             <span class="mi">2</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                             <span class="mi">3</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                             <span class="mi">4</span><span class="p">:</span> <span class="mh">0xbce3be9a</span><span class="p">,</span>
                             <span class="mi">5</span><span class="p">:</span> <span class="mh">0x12f3f6b0</span><span class="p">,</span>
                             <span class="mi">8</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">,</span>
                             <span class="mi">9</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                             <span class="mi">10</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                             <span class="mi">11</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                             <span class="mi">12</span><span class="p">:</span> <span class="mh">0xab762783</span><span class="p">,</span>
                             <span class="mi">13</span><span class="p">:</span> <span class="mh">0x287ecada</span><span class="p">,</span>
                             <span class="mi">7</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_data_mux</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_mux</span><span class="p">(</span><span class="s1">&#39;host&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_clk_rising_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the signals we write to use the rising edge of the clock.</span>

<span class="sd">        Default is falling edge. To return to the falling edge, the chip</span>
<span class="sd">        requires a power cycle (turn it off and back on).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clk_edge_bits</span> <span class="o">=</span> <span class="mb">0b11</span>

    <span class="k">def</span> <span class="nf">set_ctrl_reg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_value</span><span class="o">=</span><span class="mh">0x3010</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Configures the SPI Wishbone control register over the registerBridge.</span>

<span class="sd">        reg_value=0x3010 sets CHAR_LEN=16, ASS, IE</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_ctrl_reg</span><span class="p">(</span><span class="n">reg_value</span><span class="o">=</span><span class="n">reg_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_filter_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="c1"># TODO is this correct? and how to parameterize?</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="p">:</span>
                <span class="n">addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">])</span>
                <span class="c1"># TODO: ian has first addr of 0x19, second as 0x1a</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;Write filter addr=0x</span><span class="si">{:02X}</span><span class="s1">  value=0x</span><span class="si">{:02X}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_filter_coeffs_simultaneous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="c1"># https://opalkelly.com/examples/setting-and-getting-multiple-registers/#tab-python</span>
        <span class="n">loop_thru</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">,</span> <span class="mi">1</span>
                              <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_len</span><span class="p">)</span>
        <span class="n">regs</span> <span class="o">=</span> <span class="n">ok</span><span class="o">.</span><span class="n">okTRegisterEntries</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">loop_thru</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">loop_thru</span><span class="p">:</span>  <span class="c1"># TODO is this correct? and how to parameterize?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="p">:</span>
                <span class="n">addr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_offset</span><span class="p">)</span>
                <span class="n">regs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">addr</span>
                <span class="n">regs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span>
                <span class="c1"># TODO: ian has first addr of 0x19, second as 0x1a</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;Write filter addr=0x</span><span class="si">{:02X}</span><span class="s1">  value=0x</span><span class="si">{:02X}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegisters</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_coeff_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read two wire outs for coefficients a3 section1, scale 3</span>
<span class="sd">        debug wires available for filters 0, 1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">debug_coeff_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;COEFF_DEBUG_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">debug_coeff_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;COEFF_DEBUG_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">debug_coeff_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;COEFF_DEBUG_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">debug_coeff_3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;COEFF_DEBUG_3&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Read Coefficients:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    0:&#39;</span><span class="p">,</span> <span class="n">debug_coeff_0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    1:&#39;</span><span class="p">,</span> <span class="n">debug_coeff_1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    2:&#39;</span><span class="p">,</span> <span class="n">debug_coeff_2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    3:&#39;</span><span class="p">,</span> <span class="n">debug_coeff_3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">debug_coeff_0</span><span class="p">,</span> <span class="n">debug_coeff_1</span><span class="p">,</span> <span class="n">debug_coeff_2</span><span class="p">,</span> <span class="n">debug_coeff_3</span>

    <span class="k">def</span> <span class="nf">change_filter_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;passthru&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;passthrough&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mh">0x7fff_ffff</span><span class="p">,</span>   <span class="c1"># changed for about unity gain</span>
                                 <span class="mi">1</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">3</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">4</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">5</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">8</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">,</span>
                                 <span class="mi">9</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">10</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">11</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">12</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">13</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="mi">7</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">,</span>
                                 <span class="mi">6</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;100kHz&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mh">0x0000_6f84</span><span class="p">,</span>
                                 <span class="mi">1</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">2</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                                 <span class="mi">3</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">4</span><span class="p">:</span> <span class="mh">0x8e301ca0</span><span class="p">,</span>
                                 <span class="mi">5</span><span class="p">:</span> <span class="mh">0x32b7759a</span><span class="p">,</span>
                                 <span class="mi">8</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">,</span>
                                 <span class="mi">9</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">10</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                                 <span class="mi">11</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">12</span><span class="p">:</span> <span class="mh">0x86d2475f</span><span class="p">,</span>
                                 <span class="mi">13</span><span class="p">:</span> <span class="mh">0x3a2447ec</span><span class="p">,</span>
                                 <span class="mi">7</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">target</span> <span class="o">==</span> <span class="s1">&#39;500kHz&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_coeff</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mh">0x009e1586</span><span class="p">,</span>
                                 <span class="mi">1</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">2</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                                 <span class="mi">3</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">4</span><span class="p">:</span> <span class="mh">0xbce3be9a</span><span class="p">,</span>
                                 <span class="mi">5</span><span class="p">:</span> <span class="mh">0x12f3f6b0</span><span class="p">,</span>
                                 <span class="mi">8</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">,</span>
                                 <span class="mi">9</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">10</span><span class="p">:</span> <span class="mh">0x40000000</span><span class="p">,</span>
                                 <span class="mi">11</span><span class="p">:</span> <span class="mh">0x20000000</span><span class="p">,</span>
                                 <span class="mi">12</span><span class="p">:</span> <span class="mh">0xab762783</span><span class="p">,</span>
                                 <span class="mi">13</span><span class="p">:</span> <span class="mh">0x287ecada</span><span class="p">,</span>
                                 <span class="mi">7</span><span class="p">:</span> <span class="mh">0x7fffffff</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">ADCDATA</span><span class="p">():</span>
    <span class="c1"># TODO: add class docstring</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">deswizzle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bits</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># TODO: check the byte ordering</span>
            <span class="c1"># TODO: is breaking this up necessary? looks like it</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bits</span> <span class="o">==</span> <span class="mi">18</span><span class="p">:</span>
            <span class="c1"># TODO: check 18-bit data conversion</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;AD7961&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">d1</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">d2</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">d1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># see Xilinx FIFO guide PG057 pg 115, memory fills up from left to right (MSB to LSB)</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>
            <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ADS8686&#39;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                 <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])}</span>
            <span class="n">c</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span>
            <span class="n">c</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">convert_twos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert data to integer two&#39;s complement representation.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deswizle and convert the twos complement representation.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_twos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>

    <span class="c1"># TODO: test composite ADC function that enables, reads, converts and plots</span>
    <span class="c1"># TODO: incorporate/connect QT graphing (UIscript.py)</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">twos_comp_conv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_pipe_out</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PIPE_OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">twos_comp_conv</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_data</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">stream_mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">swps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">twos_comp_conv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data_len</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ADC stream multiple&#39;</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">timeout_time</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">swps</span> <span class="c1"># seconds </span>
        <span class="n">timeout_flg</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">timeout_time</span><span class="p">))</span>

        <span class="k">while</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">swps</span><span class="p">)</span> <span class="ow">and</span> <span class="n">timeout_flg</span><span class="p">):</span>
            <span class="c1"># check the FIFO half-full flag</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsTriggered</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FIFO_HALFFULL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FIFO_HALFFULL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_pipe_out</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PIPE_OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                            <span class="n">data_len</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>
            <span class="n">timeout_flg</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">timeout_time</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">timeout_flg</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ADC stream_mult timed out&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">twos_comp_conv</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_data</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="c1"># Class for the ADS8686 ADC chip.</span>
<span class="k">class</span> <span class="nc">ADS8686</span><span class="p">(</span><span class="n">SPIController</span><span class="p">,</span> <span class="n">ADCDATA</span><span class="p">):</span>
    <span class="c1"># TODO: add class docstring</span>

    <span class="n">registers</span> <span class="o">=</span> <span class="n">Register</span><span class="o">.</span><span class="n">get_chip_registers</span><span class="p">(</span><span class="s1">&#39;ADS8686&#39;</span><span class="p">)</span>
    <span class="n">msg_w</span> <span class="o">=</span> <span class="mh">0x8000</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">:</span>  <span class="mb">0b00</span><span class="p">,</span>
             <span class="mf">2.5</span><span class="p">:</span> <span class="mb">0b01</span><span class="p">,</span>
             <span class="mi">5</span><span class="p">:</span>   <span class="mb">0b10</span><span class="p">}</span>
    <span class="n">lpf_khz</span> <span class="o">=</span> <span class="p">{</span><span class="mi">39</span><span class="p">:</span>  <span class="mb">0b00</span><span class="p">,</span>
               <span class="mi">15</span><span class="p">:</span>  <span class="mb">0b01</span><span class="p">,</span>
               <span class="mi">376</span><span class="p">:</span> <span class="mb">0b10</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="mh">0x3010</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># master_config=0x3010 Sets CHAR_LEN=16, ASS (auto SlaveSelect),</span>
        <span class="c1"># IE (interrupt enable), Tx/Rx Pos. Edge  TODO: why was this changed??</span>
        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">get_chip_endpoints</span><span class="p">(</span><span class="s1">&#39;ADS8686&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">master_config</span><span class="o">=</span><span class="n">master_config</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span>  <span class="c1"># voltage ranges of all 16 channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bits</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;ADS8686&#39;</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">reg_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write to an internal register on the chip.&quot;&quot;&quot;</span>

        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">reg_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reg</span> <span class="o">|</span> <span class="n">ADS8686</span><span class="o">.</span><span class="n">msg_w</span> <span class="o">|</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read from an internal register on the chip.&quot;&quot;&quot;</span>

        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">reg_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">read_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read a desired channel on the chip.&quot;&quot;&quot;</span>

        <span class="k">pass</span>  <span class="c1"># TODO: write method</span>

    <span class="k">def</span> <span class="nf">read_last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the last value read by the ADS8686.</span>

<span class="sd">        This reads a wire_out rather than a pipe_out so we get 1 data point</span>
<span class="sd">        rather than many.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">byteorder</span><span class="o">=</span><span class="s1">&#39;little&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform basic setup for default chip use.&quot;&quot;&quot;</span>

        <span class="c1"># TODO -- defaults to modify the SPI setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_host_mode</span><span class="p">()</span>  <span class="c1"># required for the SPI configuration to work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_master_bin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">master_config</span><span class="p">)</span>  <span class="c1"># configures directly</span>
        <span class="c1"># self.set_frequency(5)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_divider</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># TODO: check on scope: 200/(3+1)=50 MHz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_slave</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the voltage range of all channels.</span>

<span class="sd">        If vals is a single value then all channels are given that value.</span>
<span class="sd">        If vals is a list of length 16 then each channel gets a separate range</span>
<span class="sd">        vals must be 10, 5, or 2.5. These represent +/-10, +/-5, and +/-2.5 V.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">16</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Value must be a single number of list of length 16&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="n">towrite</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">regs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rangeA1&#39;</span><span class="p">,</span> <span class="s1">&#39;rangeA2&#39;</span><span class="p">,</span> <span class="s1">&#39;rangeB1&#39;</span><span class="p">,</span> <span class="s1">&#39;rangeB2&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="n">towrite</span> <span class="o">+=</span> <span class="n">ADS8686</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing 0x</span><span class="si">{:x}</span><span class="s1"> to reg </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">towrite</span><span class="p">,</span> <span class="n">regs</span><span class="p">[</span><span class="n">idx</span><span class="o">//</span><span class="mi">4</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">towrite</span><span class="p">,</span> <span class="n">regs</span><span class="p">[</span><span class="n">idx</span><span class="o">//</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">towrite</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reg_to_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">,</span> <span class="n">chan_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the channel&#39;s voltage from the register value.</span>

<span class="sd">        Uses the stored gain range. reg_val can be list of ints or int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  TODO: setup for sequence of channels</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">reg_val</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># 16-bit channel readings</span>
        <span class="n">lsb</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">chan_num</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">*</span><span class="n">lsb</span>

    <span class="k">def</span> <span class="nf">write_reg_bridge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clk_div</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set clk divider and spi_controller to continuously read ADC data.&quot;&quot;&quot;</span>

        <span class="c1"># Configures the clock divider to determine the CONVST frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x0</span><span class="p">,</span>
                                    <span class="n">clk_div</span><span class="p">)</span>  <span class="c1"># (1/200e6)*1000 = 5 us period</span>
        <span class="c1"># now load the sequence of wishbone commands that will be sent to the SPI converter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x1</span><span class="p">,</span>
                                    <span class="mh">0x8000_0001</span><span class="p">)</span>  <span class="c1"># Tx data register</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x2</span><span class="p">,</span>
                                    <span class="mh">0x4000_0000</span><span class="p">)</span>  <span class="c1"># 0x0000 loaded into the Tx register -- for NOP</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x3</span><span class="p">,</span>
                                    <span class="mh">0x8000_0041</span><span class="p">)</span>  <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteRegister</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;REGBRIDGE_OFFSET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x4</span><span class="p">,</span>
                                    <span class="mh">0x4000_3110</span><span class="p">)</span>  <span class="c1">#</span>
        <span class="c1"># reset the clk divider</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">send_trig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;CLK_DIV_RESET&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_fpga_mode</span><span class="p">()</span>  <span class="c1"># lower the control bit for host vs. FPGA driven</span>
        <span class="c1"># so the FPGA takes control of sending SPI</span>

    <span class="k">def</span> <span class="nf">set_lpf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpf</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>

        <span class="k">if</span> <span class="n">lpf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ADS8686</span><span class="o">.</span><span class="n">lpf_khz</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in ADS8686 LPF setup.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Skipping ADS8686 LPF setup&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Frequency options are: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">ADS8686</span><span class="o">.</span><span class="n">lpf_khz</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ADS8686</span><span class="o">.</span><span class="n">lpf_khz</span><span class="p">[</span><span class="n">lpf</span><span class="p">],</span> <span class="s1">&#39;lpf&#39;</span><span class="p">)</span>  <span class="c1"># 376 khZ</span>

    <span class="k">def</span> <span class="nf">setup_sequencer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan_list</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;FIXED&#39;</span><span class="p">,</span> <span class="s1">&#39;FIXED&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;FIXED&#39;</span><span class="p">)],</span> <span class="n">voltage_range</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">lpf</span><span class="o">=</span><span class="mi">376</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start the sequencer looping through the given channels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        chan_list : list</span>
<span class="sd">            Ordered list of channel pairs (A, B) to loop through. Options below.</span>
<span class="sd">                [0-7]</span>
<span class="sd">                AVDD</span>
<span class="sd">                ALDO</span>
<span class="sd">                FIXED (0xAAAA, 0x5555)</span>
<span class="sd">        voltage_range : int</span>
<span class="sd">            Voltage range of the channels, positive and negative.</span>
<span class="sd">        lpf : int</span>
<span class="sd">            Low pass frequency in kHz.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">named_chans</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;AVDD&#39;</span><span class="p">:</span> <span class="mb">0b1000</span><span class="p">,</span>
            <span class="s1">&#39;ALDO&#39;</span><span class="p">:</span> <span class="mb">0b1001</span><span class="p">,</span>
            <span class="s1">&#39;FIXED&#39;</span><span class="p">:</span> <span class="mb">0b1011</span><span class="p">,</span>
            <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
            <span class="s1">&#39;7&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">chan_list</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chan</span><span class="p">)):</span>
                <span class="n">code_piece</span> <span class="o">=</span> <span class="n">named_chans</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">chan</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">code_piece</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ERROR: name not recognized: </span><span class="si">{</span><span class="n">chan</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">code</span> <span class="o">=</span> <span class="n">named_chans</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FIXED&#39;</span><span class="p">)</span> <span class="o">+</span> \
                        <span class="p">(</span><span class="n">named_chans</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;FIXED&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># B side shifted 4 bits left, A side at 0</span>
                    <span class="n">code</span> <span class="o">+=</span> <span class="n">code_piece</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">codes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

        <span class="c1"># Room for 32 codes, any more after that are not included</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;WARNING: too many channels. Using first 32/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span><span class="si">}</span><span class="s1"> channels&#39;</span><span class="p">)</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="n">codes</span><span class="p">[:</span><span class="mi">32</span><span class="p">]</span>
        <span class="n">base_creg</span> <span class="o">=</span> <span class="mh">0x0000</span>  <span class="c1"># default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">base_creg</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">)</span>
        <span class="c1"># set channels to be the fixed digital code</span>
        <span class="c1"># channel B = 0x5555; channel A = 0xAAAA</span>
        <span class="c1">#  this is over-written by sequencer anyways</span>
        <span class="c1"># TODO: if this is over-written anyways, do we need it?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="mh">0xb</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0xb</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)),</span> <span class="s1">&#39;chan_sel&#39;</span><span class="p">)</span>
        <span class="c1"># set the range of all channels to +/-5V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_range</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">)</span>  <span class="c1"># sets all channels to +/-5V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lpf</span><span class="p">(</span><span class="n">lpf</span><span class="p">)</span>
        <span class="c1"># setup the sequencer</span>
        <span class="c1"># sequence0: fixed values and then continue</span>
        <span class="c1">#   8 SSREN; 7-4 CHSEL_B; 3-0 CHSEL_A</span>
        <span class="n">backto_first_stack</span> <span class="o">=</span> <span class="mh">0x100</span>  <span class="c1"># SSREN is bit 8</span>

        <span class="c1"># Write all but the last code, which is done separately</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="s1">&#39;seq&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="c1"># Write last code with loop back: use (len(codes) - 1) since i is not set if len(codes)==1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">codes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">backto_first_stack</span><span class="p">),</span>
                   <span class="s1">&#39;seq&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># enable the sequencer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">base_creg</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">,</span> <span class="s1">&#39;config&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">codes</span>

    <span class="k">def</span> <span class="nf">hw_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trigger ADS8686 active low hardware reset.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>


<span class="c1"># Class for the AD7961 Fast ADC. Does not use SPI or I2C (uses LVDS).</span>
<span class="k">class</span> <span class="nc">AD7961</span><span class="p">(</span><span class="n">ADCDATA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An interface to the AD7961 ADC</span>
<span class="sd">    Passed the FPGA object</span>
<span class="sd">    Allows for multiple channels</span>
<span class="sd">    read status flags (FIFO full, empty, count and PLL)</span>
<span class="sd">    configures FPGA internal resets</span>
<span class="sd">    configures chip specific and global enables</span>
<span class="sd">    Formats data returned from the wire out</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add Attributes to docstring</span>

    <span class="c1"># the AD7961 does not have internal registers -- just OK endpoints</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">get_chip_endpoints</span><span class="p">(</span><span class="s1">&#39;AD7961&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span> <span class="o">=</span> <span class="n">fpga</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;AD7961&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_bits</span> <span class="o">=</span> <span class="mi">16</span>  <span class="c1"># for AD7961 bits=18 for AD7960</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_chips</span><span class="p">(</span><span class="n">fpga</span><span class="p">,</span> <span class="n">number_of_chips</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a given number of new chips.</span>

<span class="sd">        We increment the endpoints between each instantiation as well. The</span>
<span class="sd">        number must be greater than 0. If the endpoints argument is left</span>
<span class="sd">        as None, then we will use copies of the endpoints_from_defines</span>
<span class="sd">        dictionary for the endpoints for each instance, and update that</span>
<span class="sd">        original dictionary when we increment the endpoints. This way, the</span>
<span class="sd">        endpoints there are ready for another instantiation if needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span> <span class="ow">or</span> <span class="n">number_of_chips</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number_of_chips must be an integer greater than 0&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">endpoints_from_defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;AD7961&#39;</span><span class="p">)</span>

        <span class="n">chips</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_chips</span><span class="p">):</span>
            <span class="c1"># Use deepcopy here to keep the endpoints for different instances separate</span>
            <span class="n">chips</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AD7961</span><span class="p">(</span><span class="n">fpga</span><span class="o">=</span><span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)))</span>
            <span class="n">Endpoint</span><span class="o">.</span><span class="n">increment_endpoints</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chips</span>

    <span class="k">def</span> <span class="nf">get_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get AD796x status:</span>
<span class="sd">        pll lock, FIFO full, half-full, and empty</span>

<span class="sd">        Returns: dictionary of status</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fifo_status</span><span class="p">()</span>
        <span class="n">pll_lock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pll_status</span><span class="p">()</span>
        <span class="n">status</span><span class="p">[</span><span class="s1">&#39;pll_lock&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pll_lock</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">status</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> status of </span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                <span class="n">k</span><span class="p">,</span> <span class="n">status</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">get_pll_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get status of the phase locked loop.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PLL_LOCKED&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PLL_LOCKED&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_timing_pll_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get status of the timing of the phase locked loop.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;TIMING_PLL_LOCKED&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;TIMING_PLL_LOCKED&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_fifo_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get fullness status of the FIFO.&quot;&quot;&quot;</span>

        <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FULL&#39;</span><span class="p">,</span> <span class="s1">&#39;HALFFULL&#39;</span><span class="p">,</span> <span class="s1">&#39;EMPTY&#39;</span><span class="p">]</span>
        <span class="n">fifo_status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">UpdateTriggerOuts</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
            <span class="n">fifo_status</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">IsTriggered</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FIFO_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;FIFO_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fifo_status</span>

    <span class="c1"># Enable pins:</span>
    <span class="c1"># 0000 - power down</span>
    <span class="c1"># 1001 - enabled with ref buffer on; 28 MHZ</span>
    <span class="c1"># 0100 - test patterns on LVDS</span>
    <span class="c1"># 1101 - enabled with ref buffer on; 9 MHZ</span>
    <span class="c1"># Note that EN[3]=1 enables the VCM output buffer.</span>

    <span class="k">def</span> <span class="nf">power_down_adc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down single channel of the ADC.</span>

<span class="sd">        Fails if the global enables are 010 for LVDS test patterns</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_enables</span><span class="p">(</span><span class="mb">0b0</span><span class="p">,</span> <span class="n">global_enables</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable PRBS test pattern on the LVDS interface.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_enables</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mb">0b0100</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_up_adc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="s1">&#39;28M&#39;</span><span class="p">):</span>
        <span class="c1"># TODO: add method docstring</span>
        <span class="c1"># TODO: explain what bw should be in docstring</span>

        <span class="k">if</span> <span class="n">bw</span> <span class="o">==</span> <span class="s1">&#39;28M&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_enables</span><span class="p">(</span><span class="mb">0b1001</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bw</span> <span class="o">==</span> <span class="s1">&#39;9M&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_enables</span><span class="p">(</span><span class="mb">0b1101</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;incorrect input sampling bandwidth for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_down_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down all channels of the ADC.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_enables</span><span class="p">(</span><span class="mb">0b0000</span><span class="p">)</span>  <span class="c1"># TODO: return anything here?</span>

    <span class="k">def</span> <span class="nf">reset_pll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the phase locked loop.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PLL_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;PLL_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">reset_trig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the FPGA controller for the ADC.</span>
<span class="sd">        Common to synchronize timing </span>
<span class="sd">            (resets ad7961_timing module AND the ads8686 timing) </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ActivateTriggerIn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value of the wire to reset the FPGA controller for the ADC.</span>

<span class="sd">        Uses the Opal Kelly WireIn (the trigger can&#39;t hold the reset).</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        value : int</span>
<span class="sd">            value = 1 is reset</span>
<span class="sd">            value = 0 releases reset</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WIRE_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WIRE_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WIRE_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;WIRE_RESET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">power_down_fpga</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Power down the FPGA controller through WireIn.&quot;&quot;&quot;</span>

        <span class="c1"># TODO: add functionality (wirein bit) to the FPGA</span>
        <span class="c1">#       this would reduce FPGA power consumption</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_wire</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_enables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mb">0b0000</span><span class="p">,</span> <span class="n">global_enables</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the EN0 specific to this channel (LSB in values).</span>

<span class="sd">        Optionally also modify the global enables (all channels).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">global_enables</span><span class="p">:</span>
            <span class="c1"># global enables (connect to all AD7961); create a list of bit position</span>
            <span class="n">gl_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;GLOBAL_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
                       <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;GLOBAL_ENABLE_LEN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)]</span>
            <span class="c1"># or global mask with the signal channel EN0 mask</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span><span class="n">gl_mask</span><span class="p">)</span> <span class="o">|</span> <span class="n">mask</span>

        <span class="c1"># setup the values</span>
        <span class="n">value_chan</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mb">0b0001</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">global_enables</span><span class="p">:</span>
            <span class="c1">#  globabl enables are the 3 MSBs</span>
            <span class="n">val_global</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="mb">0b1110</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;GLOBAL_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># minus 1 since already left shifted by 1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Global value = 0x</span><span class="si">{:0x}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val_global</span><span class="p">))</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value_chan</span> <span class="o">|</span> <span class="n">val_global</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Enables setting value = 0x</span><span class="si">{:0x}</span><span class="s1"> with mask = = 0x</span><span class="si">{:0x}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reset_pll</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        0) put ADC controller into reset</span>
<span class="sd">        1) optionally reset the ADC PLL and wait for lock</span>
<span class="sd">            (only need to reset PLL on first channel)</span>
<span class="sd">        2) power up adc</span>
<span class="sd">        3) release ADC controller reset</span>
<span class="sd">        4) reset fifo</span>
<span class="sd">        5) check and return status (PLL and fifo)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_wire</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reset_pll</span><span class="p">:</span>
            <span class="c1"># reset PLL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_pll</span><span class="p">()</span>
            <span class="n">pll_cnt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pll_status</span><span class="p">():</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
                <span class="n">pll_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pll_cnt</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PLL lock timeout&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># enable ADC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">power_up_adc</span><span class="p">()</span>
        <span class="c1"># now that PLL is locked and ADC is ready</span>
        <span class="c1"># release the reset of the ADC controller</span>
        <span class="c1"># self.reset_trig()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_wire</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># releases the reset</span>
        <span class="c1"># reset FIFO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fifo</span><span class="p">()</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_status</span><span class="p">()</span>
        <span class="c1"># TODO: the FIFO is guaranteed to overflow</span>
        <span class="k">return</span> <span class="n">status</span>


<div class="viewcode-block" id="DDR3"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3">[docs]</a><span class="k">class</span> <span class="nc">DDR3</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The DDR is divided into 2 buffers. Each buffer has an incoming and outgoing FIFO.</span>

<span class="sd">    **1st buffer:**</span>

<span class="sd">    * Function generator like data that provides a data-stream to the DACs</span>
<span class="sd">    * Write from the host when DAC_WRITE_ENABLE is set (clear dac read and clear adc read and write)</span>
<span class="sd">    * Organized into groups of 16 bits to 8 channels</span>
<span class="sd">    * Read to the DACs with set_dac_read</span>
<span class="sd">    * 6 AD5453 (14 bits each)</span>
<span class="sd">    * 2 DAC80508 (16 bits each) </span>
<span class="sd">    * DAC80508 channel data in the MSBs of the AD5453 stream</span>
<span class="sd">    * FIFO: OpalKelly in -&gt; out to DDR [32bits x 1024words = 4096 bytes]</span>
<span class="sd">    * FIFO: DDR in -&gt; DAC data out [out: 256bits x 256 = 8192 bytes]</span>

<span class="sd">    **2nd buffer:**</span>

<span class="sd">    * Buffering for ADC data (AD7961; ADS8686), DAC outgoing data, timestamps.</span>
<span class="sd">    * ADC data writes to the DDR set_adc_write()</span>
<span class="sd">    * ADC data in DDR can be read to the host with set_adc_read()</span>
<span class="sd">    * The DDR througput is sufficient for 1st buffer reading while reading and writing to the 2nd buffer</span>
<span class="sd">    * FIFO: OpalKelly in -&gt; out to DDR [in: 32bits x 1024words = 4096 bytes]</span>
<span class="sd">    * FIFO: DDR in -&gt; OpalKelly out [256bits x 128 = 4096 bytes] OpalKelly block size is half this.</span>

<span class="sd">    **Expected sequence of operations:**</span>

<span class="sd">    1) At startup write pattern for DACs using write_channels() [set_dac_write(), clear_dac_write() are called within write_channels()]</span>
<span class="sd">    2) set_dac_read() # starts DAC data output to DACs via SPI and then set_adc_write() ADC data captured into DDR</span>
<span class="sd">    3) set_adc_read() # allows host to read PipeOut as PipeOut is continuously filled if emptied</span>

<span class="sd">    **ADC data ordering and saving:**</span>

<span class="sd">    * deswizzle()</span>
<span class="sd">    * save_data()</span>

<span class="sd">    **DDR configuration bits:**</span>

<span class="sd">    * DAC_WRITE_ENABLE</span>
<span class="sd">    * DAC_READ_ENABLE</span>
<span class="sd">    * ADC_WRITE_ENABLE</span>
<span class="sd">    * ADC_TRANSFER_ENABLE</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpga</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_version</span><span class="o">=</span><span class="s1">&#39;ADC_NO_TIMESTAMPS&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">Endpoint</span><span class="o">.</span><span class="n">get_chip_endpoints</span><span class="p">(</span><span class="s1">&#39;DDR3&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span> <span class="o">=</span> <span class="n">fpga</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;BLOCK_SIZE&#39;</span><span class="p">:</span> <span class="mi">2048</span><span class="p">,</span> <span class="c1"># 1/2 the incoming FIFO depth in bytes (size of the BlockPipeIn)</span>
                           <span class="s1">&#39;sample_size&#39;</span><span class="p">:</span> <span class="mi">65536</span><span class="p">,</span>  <span class="c1"># per channel</span>
                           <span class="c1"># number of channels that the DDR is striped between (for DACs)</span>
                           <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                           <span class="s1">&#39;update_period&#39;</span><span class="p">:</span> <span class="mf">400e-9</span><span class="p">,</span>  <span class="c1"># 2.5 MHz -- requires SCLK ~ 50 MHZ</span>
                           <span class="s1">&#39;port1_index&#39;</span><span class="p">:</span> <span class="mh">0x7f_ff_f8</span><span class="p">,</span>
                           <span class="s1">&#39;adc_channels&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="c1"># number of 2 byte chunks in DDR</span>
                           <span class="s1">&#39;adc_period&#39;</span><span class="p">:</span> <span class="mf">200e-9</span>
                           <span class="p">}</span> 

        <span class="c1"># the index is the DDR address that the circular buffer stops at.</span>
        <span class="c1"># need to write all the way up to this stoping point otherwise the SPI output will glitch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;port1_index&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_version</span>  <span class="c1"># sets deswizzling mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear_adc_debug</span><span class="p">()</span>

<div class="viewcode-block" id="DDR3.set_adc_debug"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_adc_debug">[docs]</a>    <span class="k">def</span> <span class="nf">set_adc_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the ADC debug bit.</span>

<span class="sd">        That bit multiplexes a counter to ADC channel 0 and bits 47:0 of the</span>
<span class="sd">        DAC data to ADC channels 1,2,3.</span>

<span class="sd">        Not supported in all versions of the FPGA design.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_DEBUG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_DEBUG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.clear_adc_debug"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_adc_debug">[docs]</a>    <span class="k">def</span> <span class="nf">clear_adc_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the ADC debug bit.</span>

<span class="sd">        DDR ADC data will be from the ADC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_DEBUG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_DEBUG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.make_flat_voltage"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.make_flat_voltage">[docs]</a>    <span class="k">def</span> <span class="nf">make_flat_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a constant unit16 array of value amplitude.</span>

<span class="sd">        Array length based on the sample_size parameter. The conversion from</span>
<span class="sd">        float or int voltage to int digital (binary) code should take place</span>
<span class="sd">        BEFORE this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amplitude: int</span>
<span class="sd">            Digital (binary) value of the flat voltage</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            amplitude : numpy.ndarray </span>
<span class="sd">                to be assigned to DDR data array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">amplitude</span>
        <span class="n">amplitude</span> <span class="o">=</span> <span class="n">amplitude</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">amplitude</span></div>

<div class="viewcode-block" id="DDR3.closest_frequency"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.closest_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">closest_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine closest frequency so the waveform evenly divides into the length of the DDR3</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : float</span>
<span class="sd">            Desired frequency</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_frequency : float </span>
<span class="sd">            The closest possible frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">samples_per_period</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;update_period&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">samples_per_period</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Frequency is too high for the DDR update rate&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">total_periods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">samples_per_period</span>
        <span class="c1"># round and recalculate frequency</span>
        <span class="n">round_total_periods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">total_periods</span><span class="p">)</span>
        <span class="n">round_samples_per_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span> <span class="o">/</span> \
            <span class="n">round_total_periods</span>
        <span class="n">new_frequency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;update_period&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">round_samples_per_period</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_frequency</span></div>

<div class="viewcode-block" id="DDR3.make_sine_wave"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.make_sine_wave">[docs]</a>    <span class="k">def</span> <span class="nf">make_sine_wave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span>
                       <span class="n">offset</span><span class="o">=</span><span class="mh">0x2000</span><span class="p">,</span> <span class="n">actual_frequency</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a sine-wave array for writing to DDR.</span>

<span class="sd">        The conversion from float or int voltage to int digital (binary) code</span>
<span class="sd">        should take place BEFORE this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amplitude : int</span>
<span class="sd">            Digital (binary) value of the sine wave.</span>
<span class="sd">        frequency : float</span>
<span class="sd">            Desired frequency in Hz.</span>
<span class="sd">        offset : int</span>
<span class="sd">            Digital (binary) value offset.</span>
<span class="sd">        actual_frequency : bool</span>
<span class="sd">            Decide whether closest frequency that fits an integer number of periods is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ddr_seq : numpy.ndarray </span>
<span class="sd">            to be assigned to DDR data array  </span>

<span class="sd">        frequency : float</span>
<span class="sd">            actual frequency after closest_frequency</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">amplitude</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: amplitude in sine-wave is too large&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">actual_frequency</span><span class="p">:</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_frequency</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;update_period&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;update_period&#39;</span><span class="p">])</span>
        <span class="c1"># print(&#39;length of time axis after creation &#39;, len(t))</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="p">(</span><span class="n">amplitude</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">frequency</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ddr_seq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">ddr_seq</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: Uint16 overflow in make sine wave&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">ddr_seq</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ddr_seq</span><span class="p">,</span> <span class="n">frequency</span></div>

<div class="viewcode-block" id="DDR3.make_ramp"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.make_ramp">[docs]</a>    <span class="k">def</span> <span class="nf">make_ramp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">actual_length</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a ramp signal to write to the DDR.</span>

<span class="sd">        The conversion from float or int voltage to int digital (binary) code</span>
<span class="sd">        should take place BEFORE this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int</span>
<span class="sd">            Digital (binary) value to start the ramp at</span>
<span class="sd">        stop : int</span>
<span class="sd">            Digital (binary) value to stop the ramp at</span>
<span class="sd">        step : int</span>
<span class="sd">            Digital (binary) code to step by</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            ddr_seq : numpy.ndarray </span>
<span class="sd">                to be assigned to DDR data array        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># change the stop value for integer number of cycles</span>
        <span class="n">ramp_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">len_ramp_seq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">actual_length</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">len_ramp_seq</span><span class="p">))</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="o">*</span><span class="n">step</span>
            <span class="n">ramp_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">num_tiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">)</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">)</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">,</span> <span class="n">num_tiles</span><span class="p">)</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ddr_seq</span><span class="p">,</span> <span class="n">ramp_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">extras</span><span class="p">]))</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">ddr_seq</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ddr_seq</span></div>

<div class="viewcode-block" id="DDR3.make_step"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.make_step">[docs]</a>    <span class="k">def</span> <span class="nf">make_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">actual_length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">duty</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a step signal (square wave) to write to the DDR.</span>

<span class="sd">        The conversion from float or int voltage to int digital (binary) code</span>
<span class="sd">        should take place BEFORE this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        low : int</span>
<span class="sd">            Digital (binary) code for the low value of the step.</span>
<span class="sd">        high : int</span>
<span class="sd">            Digital (binary) code for the high value of the step.</span>
<span class="sd">        length : TODO add type for length</span>
<span class="sd">            TODO add description for length</span>
<span class="sd">        actual_length : bool</span>
<span class="sd">            TODO add description for actual_length</span>
<span class="sd">        duty : int or float</span>
<span class="sd">            Duty cycle percentage. Enter as a percentage [0.0, 100.0].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ddr_seq : numpy.ndarray </span>
<span class="sd">            to be assigned to DDR data array  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">actual_length</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">length</span><span class="p">))</span>
        <span class="n">l_first</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="n">duty</span><span class="p">)</span>
        <span class="n">l_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">duty</span><span class="p">))</span>
        <span class="n">ramp_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">l_first</span><span class="p">)</span><span class="o">*</span><span class="n">low</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">l_end</span><span class="p">)</span><span class="o">*</span><span class="n">high</span><span class="p">))</span>
        <span class="n">num_tiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">)</span>
        <span class="n">extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">)</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ramp_seq</span><span class="p">,</span> <span class="n">num_tiles</span><span class="p">)</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ddr_seq</span><span class="p">,</span> <span class="n">ramp_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">extras</span><span class="p">]))</span>
        <span class="n">ddr_seq</span> <span class="o">=</span> <span class="n">ddr_seq</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ddr_seq</span></div>

<div class="viewcode-block" id="DDR3.write_channels"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.write_channels">[docs]</a>    <span class="k">def</span> <span class="nf">write_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_ddr_read</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the channels as striped data to the DDR.&quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;channels&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># extra order swap on the 32 bit wide pipe</span>
                <span class="n">data</span><span class="p">[(</span><span class="mi">7</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)::</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[(</span><span class="mi">7</span><span class="o">-</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)::</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of data DDR data [2 byte words] = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">set_ddr_read</span><span class="o">=</span><span class="n">set_ddr_read</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.write"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">set_ddr_read</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a bytearray to the DDR3.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buf : bytearray</span>
<span class="sd">            bytearray to write to the DDR</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        block_pipe_return : int</span>
<span class="sd">            length of the buffer written to the DDR (or error code if unsuccessful)</span>
<span class="sd">        speed_MBs : float</span>
<span class="sd">            speed of the write in MB/s</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Length of buffer being written to DDR [bytes]: &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_dac_read</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fifo</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;DAC_IN&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dac_write</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing to DDR...&#39;</span><span class="p">)</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">block_pipe_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">WriteToBlockPipeIn</span><span class="p">(</span><span class="n">epAddr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;BLOCK_PIPE_IN&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                                             <span class="n">blockSize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;BLOCK_SIZE&#39;</span><span class="p">],</span>
                                                             <span class="n">data</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The length of the DDR write was </span><span class="si">{</span><span class="n">block_pipe_return</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">time2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">time3</span> <span class="o">=</span> <span class="p">(</span><span class="n">time2</span><span class="o">-</span><span class="n">time1</span><span class="p">)</span>
        <span class="n">speed_MBs</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">block_pipe_return</span><span class="o">/</span><span class="mi">1024</span><span class="o">/</span><span class="mi">1024</span><span class="o">/</span><span class="n">time3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The speed of the write was </span><span class="si">{</span><span class="n">speed_MBs</span><span class="si">}</span><span class="s1"> MB/s&#39;</span><span class="p">)</span>

        <span class="c1"># below prepares the HDL into read mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_dac_write</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">set_ddr_read</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_dac_read</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_adc_read</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">block_pipe_return</span><span class="p">,</span> <span class="n">speed_MBs</span></div>

<div class="viewcode-block" id="DDR3.reset_mig_interface"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.reset_mig_interface">[docs]</a>    <span class="k">def</span> <span class="nf">reset_mig_interface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset user interface to the MIG (memory interface generator). Resets</span>
<span class="sd">            the DDR address pointers for read/write of both buffers </span>
<span class="sd">            (does not reset the MIG controller).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">send_trig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;UI_RESET&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="DDR3.fifo_status"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.fifo_status">[docs]</a>    <span class="k">def</span> <span class="nf">fifo_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the empty, full, and count status of the DDR interfacing FIFOs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fifo_status : dict </span>
<span class="sd">            dictionary of fifo status (&#39;EMPTY&#39;, &#39;FULL&#39;, &#39;ADC_DATA_COUNT&#39;) for &#39;IN&#39;, &#39;OUT&#39;, and channels 1, 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wire_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">read_wire</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;INIT_CALIB_COMPLETE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="n">fifo_status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fe</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;EMPTY&#39;</span><span class="p">,</span> <span class="s1">&#39;FULL&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">inout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;IN&#39;</span><span class="p">,</span> <span class="s1">&#39;OUT&#39;</span><span class="p">]:</span>
                    <span class="n">ep_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inout</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">fe</span><span class="p">)</span>
                    <span class="n">bit_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">wire_status</span><span class="p">,</span> <span class="n">bit_pos</span><span class="p">)</span>
                    <span class="n">fifo_status</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ep_name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

        <span class="n">ep_name</span> <span class="o">=</span> <span class="s1">&#39;ADC_DATA_COUNT&#39;</span>
        <span class="n">cnt_bit_low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span>
        <span class="n">cnt_bit_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_width</span>
        <span class="n">cnt_msk</span> <span class="o">=</span> <span class="n">gen_mask</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cnt_bit_low</span><span class="p">,</span> <span class="n">cnt_bit_width</span><span class="p">))</span>
        <span class="n">fifo_status</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wire_status</span> <span class="o">&amp;</span> <span class="n">cnt_msk</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">cnt_bit_low</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ep_name</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

        <span class="c1"># self.print_fifo_status(fifo_status)</span>
        <span class="k">return</span> <span class="n">fifo_status</span></div>

<div class="viewcode-block" id="DDR3.print_fifo_status"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.print_fifo_status">[docs]</a>    <span class="k">def</span> <span class="nf">print_fifo_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fifo_status</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the FIFO status dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fifo_status : dict</span>
<span class="sd">            Dictionary of fifo status.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fifo_status</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">fifo_status</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span></div>

<div class="viewcode-block" id="DDR3.set_dac_read"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_dac_read">[docs]</a>    <span class="k">def</span> <span class="nf">set_dac_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set DDR / FIFOs read enable. Enables DDR data going to the </span>
<span class="sd">        DACs and ADC data into DDR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_READ_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_READ_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.clear_dac_read"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_dac_read">[docs]</a>    <span class="k">def</span> <span class="nf">clear_dac_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear DDR / FIFOs read enable. Stops DDR data from going to </span>
<span class="sd">        the DACs and ADC data into DDR</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_READ_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_READ_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.set_dac_write"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_dac_write">[docs]</a>    <span class="k">def</span> <span class="nf">set_dac_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set DDR / FIFOs write enable into DDR via Pipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.clear_dac_write"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_dac_write">[docs]</a>    <span class="k">def</span> <span class="nf">clear_dac_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear DDR / FIFOs write enable into DDR via Pipe.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.set_adc_write"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_adc_write">[docs]</a>    <span class="k">def</span> <span class="nf">set_adc_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set DDR / FIFOs write enable ADC data into DDR.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.set_adc_dac_simultaneous"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_adc_dac_simultaneous">[docs]</a>    <span class="k">def</span> <span class="nf">set_adc_dac_simultaneous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set DDR / FIFOs read enable. Enables DDR data going to the </span>
<span class="sd">        DACs and ADC data into DDR</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bit_addr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;DAC_READ_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_TRANSFER_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">]</span>
        <span class="n">bit_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_ep_simultaneous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                      <span class="n">bit_addr</span><span class="p">,</span> <span class="n">bit_vals</span><span class="p">)</span></div>


<div class="viewcode-block" id="DDR3.clear_adc_write"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_adc_write">[docs]</a>    <span class="k">def</span> <span class="nf">clear_adc_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear DDR / FIFOs write enable ADC data into DDR.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_WRITE_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.set_adc_read"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_adc_read">[docs]</a>    <span class="k">def</span> <span class="nf">set_adc_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set DDR / FIFO read enable DDR data from the ADCs out via a PipeOut.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_TRANSFER_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_TRANSFER_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.clear_adc_read"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_adc_read">[docs]</a>    <span class="k">def</span> <span class="nf">clear_adc_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear DDR / FIFO read enable DDR data from the ADCs out via a PipeOut.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_TRANSFER_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_TRANSFER_ENABLE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.set_adcs_connected"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_adcs_connected">[docs]</a>    <span class="k">def</span> <span class="nf">set_adcs_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set that AD7961s are connected to the FPGA so that DDR3 write enable comes from </span>
<span class="sd">            the AD7961.v module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;USE_ADC_READY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;USE_ADC_READY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.clear_adcs_connected"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.clear_adcs_connected">[docs]</a>    <span class="k">def</span> <span class="nf">clear_adcs_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; AD7961s are not connected to the FPGA so the DDR3 write enable signal is emulated</span>
<span class="sd">            by the global_timing module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;USE_ADC_READY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;USE_ADC_READY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>

<div class="viewcode-block" id="DDR3.reset_fifo"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.reset_fifo">[docs]</a>    <span class="k">def</span> <span class="nf">reset_fifo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset FIFO interfaces to DDR .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fifo_reset_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DAC_IN&#39;</span><span class="p">,</span> <span class="s1">&#39;DAC_READ&#39;</span><span class="p">,</span> <span class="s1">&#39;ADC_IN&#39;</span><span class="p">,</span> <span class="s1">&#39;ADC_TRANSFER&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fifo_reset_names</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;DDR3 FIFO reset name of </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> is not in list of </span><span class="si">{</span><span class="n">fifo_reset_names</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ALL&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name_tmp</span> <span class="ow">in</span> <span class="n">fifo_reset_names</span><span class="p">:</span>
                    <span class="n">ep_name</span> <span class="o">=</span> <span class="s1">&#39;FIFO_&#39;</span> <span class="o">+</span> <span class="n">name_tmp</span> <span class="o">+</span> <span class="s1">&#39;_RST&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ep_name</span> <span class="o">=</span> <span class="s1">&#39;FIFO_&#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_RST&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">clear_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span></div>


<div class="viewcode-block" id="DDR3.adc_single"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.adc_single">[docs]</a>    <span class="k">def</span> <span class="nf">adc_single</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set ADC read address to the ADC write address.</span>

<span class="sd">        Emulates an immediate &quot;trigger&quot; of an oscilloscope.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">set_wire_bit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_ADDR_SET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_ADDR_SET&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bit_index_low</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">send_trig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;ADC_ADDR_RESET&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="DDR3.read_adc_block"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.read_adc_block">[docs]</a>    <span class="k">def</span> <span class="nf">read_adc_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;ADC&#39;</span><span class="p">,</span> <span class="n">DEBUG_PRINT</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read ADC (and other) DDR data. </span>
<span class="sd">        Block size must be a power of two from 16 to 16384</span>
<span class="sd">        will automatically perform multiple transfers to complete the full LENGTH.</span>
<span class="sd">        The length must be an integer multiple of 16 for USB3.0</span>
<span class="sd">        and the length must be an Integer multiple of Block Size.</span>
<span class="sd">        see https://docs.opalkelly.com/fpsdk/frontpanel-api/ section 3.3.1</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_size : int</span>
<span class="sd">            Length of read in bytes. If none uses DDR parameter &#39;sample_size.&#39;</span>

<span class="sd">        source : str</span>
<span class="sd">            FIFO output buffer to read. Either &#39;ADC&#39; or &#39;FG&#39;. &#39;FG&#39; just reads</span>
<span class="sd">            back what is written for DACs (as function generator) so not so</span>
<span class="sd">            useful.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_buf : byearray</span>
<span class="sd">            adc data read as a bytearray</span>
<span class="sd">        read_cnt : int</span>
<span class="sd">            The count (or error code) read from the OpalKelly interface</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;sample_size&#39;</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">data_buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)</span>

        <span class="n">block_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;BLOCK_SIZE&#39;</span><span class="p">]</span>
        <span class="c1"># check block size</span>
        <span class="k">if</span> <span class="n">block_size</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in read adc. Block size is not a multiple of 16&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">block_size</span> <span class="o">&gt;</span> <span class="mi">16384</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in read adc. Block size is greater than 16384&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;ADC&#39;</span><span class="p">:</span>
            <span class="n">read_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ReadFromBlockPipeOut</span><span class="p">(</span><span class="n">epAddr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;BLOCK_PIPE_OUT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                                          <span class="n">blockSize</span><span class="o">=</span><span class="n">block_size</span><span class="p">,</span>
                                                          <span class="n">data</span><span class="o">=</span><span class="n">data_buf</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">source</span> <span class="o">==</span> <span class="s1">&#39;FG&#39;</span><span class="p">:</span>  <span class="c1"># TODO: test, don&#39;t expect this to work</span>
            <span class="n">read_cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpga</span><span class="o">.</span><span class="n">xem</span><span class="o">.</span><span class="n">ReadFromBlockPipeOut</span><span class="p">(</span><span class="n">epAddr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="s1">&#39;BLOCK_PIPE_OUT_FG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">address</span><span class="p">,</span>
                                                          <span class="n">blockSize</span><span class="o">=</span><span class="n">block_size</span><span class="p">,</span>
                                                          <span class="n">data</span><span class="o">=</span><span class="n">data_buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect source in read_adc&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">11</span>

        <span class="k">if</span> <span class="n">DEBUG_PRINT</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;The length [num of bytes] of the BlockPipeOut read is: </span><span class="si">{</span><span class="n">read_cnt</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_buf</span><span class="p">,</span> <span class="n">read_cnt</span></div>

<div class="viewcode-block" id="DDR3.deswizzle"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.deswizzle">[docs]</a>    <span class="k">def</span> <span class="nf">deswizzle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">convert_twos</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reorder DDR data to match the ADC channels. Shift MSBytes up by 8 </span>
<span class="sd">        and combine with LSBytes. Swap channels to match ADC channel numbering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        d : array</span>
<span class="sd">            array of bytes. </span>
<span class="sd">        convert_twos : Boolean</span>
<span class="sd">            if true converts data to signed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chan_data : dict</span>
<span class="sd">            dictionary of data arrays (keys are channel numbers)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="mi">16</span>
        <span class="n">chan_data_swz</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># this data is swizzled</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ADC_NO_TIMESTAMPS&#39;</span><span class="p">:</span>  <span class="c1"># first version of ADC data before DACs + timestamps are stored</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">chan_data_swz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">::</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">::</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

            <span class="n">chan_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">convert_twos</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">chan_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">chan_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bits</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;TIMESTAMPS&#39;</span><span class="p">:</span>  <span class="c1"># first version of ADC data before DACs + timestamps are stored</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
                <span class="n">chan_data_swz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">::</span> <span class="mi">16</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">::</span> <span class="mi">16</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>

            <span class="n">chan_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>            
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>            
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

            <span class="n">chan_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data_swz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">chan_data</span></div>


<div class="viewcode-block" id="DDR3.data_to_names"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.data_to_names">[docs]</a>    <span class="k">def</span> <span class="nf">data_to_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chan_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put deswizzled data into dictionaries with names that match with the data sources. </span>
<span class="sd">        Complete twos complement conversion where necessary. Check timestamps for skips.</span>
<span class="sd">        Check the constant values for errors.</span>

<span class="sd">        This supports 2 versions of the FPGA code:</span>
<span class="sd">        &#39;ADC_NO_TIMESTAMPS&#39;: DDR data is only the fast ADC. AD7961</span>
<span class="sd">        &#39;TIMESTAMPS&#39;: DDR data is numerous. AD7961, AD5453 out, ADS8686, timestamps, readcheck</span>


<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        chan_data : dict of np.arrays</span>
<span class="sd">            data from reading DDR (minimally processed into 2 byte containers)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adc_data : dict </span>
<span class="sd">            fast adc data (double format @ 5 MSPS)</span>
<span class="sd">        timestamp : np.array  </span>
<span class="sd">            timestamps</span>
<span class="sd">        dac_data : dict </span>
<span class="sd">            DAC output data</span>
<span class="sd">        ads : dict </span>
<span class="sd">            ADS8686 ADC data (double format @ 1 MSPS)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ADC_NO_TIMESTAMPS&#39;</span><span class="p">:</span>  <span class="c1"># first version of ADC data before DACs + timestamps are stored</span>
            <span class="n">adc_data</span> <span class="o">=</span> <span class="n">chan_data</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">read_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">dac_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;TIMESTAMPS&#39;</span><span class="p">:</span>  <span class="c1"># first version of ADC data before DACs + timestamps are stored</span>
            
            <span class="n">adc_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">adc_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">chan_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
            
            <span class="n">lsb</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
            <span class="n">mid_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">msb</span> <span class="o">=</span> <span class="p">((</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">2</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
            <span class="n">t_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">msb</span><span class="p">)</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="p">(</span><span class="n">lsb</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">t_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">mid_b</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">t_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">msb</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">t_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

            <span class="n">read_check</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">read_check</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">3</span><span class="p">::</span><span class="mi">10</span><span class="p">]</span>
            <span class="n">read_check</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">4</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span>
            <span class="n">read_check</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">8</span><span class="p">::</span><span class="mi">10</span><span class="p">]</span>

            <span class="n">dac_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dac_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">dac_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">dac_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">dac_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># dac channels 4,5 are available but not every sample. skip for now. TODO: add channels 4,5</span>

            <span class="n">ads</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ads</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">::</span><span class="mi">5</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
            <span class="n">ads</span><span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">twos_comp</span><span class="p">(</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">5</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>

            <span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># check that the constant values are constant </span>
            <span class="n">constant_values</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mh">0xaa55</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mh">0x28ab</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mh">0x77bb</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">read_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error in constant value: </span><span class="si">{</span><span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of errors: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">read_check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># check the timestamps for a skip</span>
            <span class="n">unq_time_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">unq_time_intervals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Multiple time intervals&#39;</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="n">adc_data</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">dac_data</span><span class="p">,</span> <span class="n">ads</span><span class="p">,</span> <span class="n">error</span></div>

<div class="viewcode-block" id="DDR3.save_data"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.save_data">[docs]</a>    <span class="k">def</span> <span class="nf">save_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">num_repeats</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">blk_multiples</span> <span class="o">=</span> <span class="mi">40</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        read and save DDR data to an hdf file </span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        data_dir : string</span>
<span class="sd">            directory for data</span>
<span class="sd">        file_name : string</span>
<span class="sd">            filename to save data (does not append extension).</span>
<span class="sd">        num_repeats : int</span>
<span class="sd">            total data read is 2048 bytes * num_repeats * blk_multiples</span>
<span class="sd">        blk_multiples : int </span>
<span class="sd">            number of blocks read by adc_read. adc_read is a single OpalKelly API call </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chan_data : dict</span>
<span class="sd">            dictionary of data arrays (keys are channel numbers)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;BLOCK_SIZE&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">blk_multiples</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_channels&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># readings per ADC</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">adc_readings</span> <span class="o">=</span> <span class="n">chunk_size</span><span class="o">*</span><span class="n">num_repeats</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Anticipated chunk size (readings per channel) </span><span class="si">{</span><span class="n">chunk_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading </span><span class="si">{</span><span class="n">adc_readings</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">1024</span><span class="si">}</span><span class="s1"> kB per ADC channel for a total of </span><span class="si">{</span><span class="n">adc_readings</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;adc_period&quot;</span><span class="p">]</span><span class="o">*</span><span class="mi">1000</span><span class="si">}</span><span class="s1"> ms of data&#39;</span><span class="p">)</span>

        <span class="n">full_data_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">full_data_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_adc_read</span><span class="p">()</span>  <span class="c1"># enable data into the ADC reading FIFO</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">adc_readings</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_period&#39;</span><span class="p">])</span>

        <span class="c1"># Save ADC DDR data to a file</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">full_data_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">data_set</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;adc&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_channels&#39;</span><span class="p">],</span> <span class="n">chunk_size</span><span class="p">),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_channels&#39;</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">repeat</span> <span class="o">&lt;</span> <span class="n">num_repeats</span><span class="p">:</span>
                <span class="n">d</span><span class="p">,</span> <span class="n">bytes_read_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_adc</span><span class="p">(</span><span class="n">blk_multiples</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;ADC_NO_TIMESTAMPS&#39;</span><span class="p">:</span>
                    <span class="n">chan_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;data_version&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;TIMESTAMPS&#39;</span><span class="p">:</span>
                    <span class="n">chan_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deswizzle</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_channels&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                    <span class="n">chan_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;adc_channels&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">8</span><span class="p">:</span>
                    <span class="n">chan_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">chan_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                            <span class="n">chan_data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">chan_data</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span>

                <span class="n">repeat</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">repeat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Chunk size by chan data size </span><span class="si">{</span><span class="n">chunk_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">data_set</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">chan_stack</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data_set</span><span class="p">[:,</span> <span class="o">-</span><span class="n">chunk_size</span><span class="p">:]</span> <span class="o">=</span> <span class="n">chan_stack</span>
                <span class="k">if</span> <span class="n">repeat</span> <span class="o">&lt;</span> <span class="n">num_repeats</span><span class="p">:</span>
                    <span class="n">data_set</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">data_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Done with DDR reading: saved as </span><span class="si">{</span><span class="n">full_data_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chan_data</span></div>


<div class="viewcode-block" id="DDR3.read_adc"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.read_adc">[docs]</a>    <span class="k">def</span> <span class="nf">read_adc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blk_multiples</span><span class="o">=</span><span class="mi">2048</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        read DDR data into a numpy buffer of bytes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        blk_multiples : int</span>
<span class="sd">            total size of the read is blk_multiples * block_size  </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d : bytearray</span>
<span class="sd">            data as uint32    </span>
<span class="sd">        bytes_read_error : int </span>
<span class="sd">            bytes read or error code          </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t</span><span class="p">,</span> <span class="n">bytes_read_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_adc_block</span><span class="p">(</span>  <span class="c1"># just reads from the block pipe out</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;BLOCK_SIZE&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">blk_multiples</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bytes read: </span><span class="si">{</span><span class="n">bytes_read_error</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">bytes_read_error</span></div>


<div class="viewcode-block" id="DDR3.set_index"><a class="viewcode-back" href="../../DDR.html#interfaces.interfaces.DDR3.set_index">[docs]</a>    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">factor2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        No longer used. Index (the DDR address that wraps-around to 0).</span>
<span class="sd">        This is now fixed to improve timing performance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Set index is no longer used. Index is fixed to: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;port1_index&#39;</span><span class="p">]))</span></div></div>


<span class="c1"># TODO: should there be a &#39;device&#39; or similar class that all controllers are subclasses of?</span>
<span class="k">def</span> <span class="nf">disp_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Display endpoints and registers for a chip.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dev : I2CController or SPIController or SPIFifoDriven or AD7961</span>
<span class="sd">        Chip instance to display information for.</span>
<span class="sd">    reg : bool</span>
<span class="sd">        Whether to display registers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Displaying endpoints&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dev</span><span class="o">.</span><span class="n">endpoints</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dev</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reg</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Displaying registers&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">dev</span><span class="o">.</span><span class="n">registers</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="s1">&#39;: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dev</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, University of St. Thomas CpE/EE Instrumentation Group.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>