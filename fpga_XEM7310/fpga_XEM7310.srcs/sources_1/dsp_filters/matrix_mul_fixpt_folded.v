// -------------------------------------------------------------
// 
// File Name: /Users/koer2434/My Drive/UST/research/covg/manuscripts/control_system/secord_memos/obersver_nov_update/codegen/observer_fixedpt/hdlsrc/observer_fixedpt_fixpt.v
// Created: 2022-12-10 07:33:51
// 
// Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
// and then considerably modified by Lucas Koerner to use a folded approach 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Design base rate: 0.025
// Explicit user oversample request: 40x
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out_0                          ce_out        1
// out_1                          ce_out        1
// -- -------------------------------------------------------------
// 
// This matrix muliplier retains full precision. 16 bits in * 16 bits in and output is 33 bits 
//  rounding and other scaling should be done outside of the module (or by scaling the inputs)
// -------------------------------------------------------------


`timescale 1 ns / 1 ns

module matrix_mul_fixpt_folded
#(parameter A_wid = 'd16,
parameter B_wid = 'd16)
          (clk,
           reset,
           clk_enable,
           A_0,
           A_1,
           A_2,
           A_3,
           B_0,
           B_1,
           ce_out,
           out_0,
           out_1);

  //parameter out_wid = A_wid + B_wid + 1;  // width of matrix multiplication output 

  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [(A_wid-1):0] A_0;  
  input   signed [(A_wid-1):0] A_1;  
  input   signed [(A_wid-1):0] A_2;  
  input   signed [(A_wid-1):0] A_3;  
  input   signed [(B_wid-1):0] B_0;  
  input   signed [(B_wid-1):0] B_1;  
  output  reg ce_out;
  output  reg signed [(A_wid + B_wid + 1 -1):0] out_0; 
  output  reg signed [(A_wid + B_wid + 1 -1):0] out_1;  

  parameter PIPE_DLY = 5'd6 + 5'd2; // pipeline delay of the Xilinx multiplier (6 - listed as "optimal" by IP generator) combined with delay to get inputs into multiplier

  wire enb_1_1_1;
  wire enb_40_1_0;

  wire signed [(A_wid-1):0] A [0:3];  
  wire signed [(B_wid-1):0] B [0:1];  

  // 2x2*2x1 = 2x1
  // reshape as a matrix. Output is out[0] = A[0]*B[0] + A[1]*[B1]; out[1] = A[2]*B[0] + A[3]*[B1]
  assign A[0] = A_0;  
  assign A[2] = A_1; // this swapping is to match the behavior of MATLAB's reshape. 
  assign A[1] = A_2; // this swapping is to match the behavior of MATLAB's reshape.
  assign A[3] = A_3;

  assign B[0] = B_0;
  assign B[1] = B_1;

  /*wire clk_enable_1;
  matrix_mul_fixpt_enb_bypass u_matrix_mul_fixpt_enb_bypass (.clk_1(clk),
                                                                             .reset_1(reset),
                                                                             .clk_enable_1(clk_enable),
                                                                             .clk_enable_2(clk_enable_1)
                                                                             );


  wire [5:0] counter;
  matrix_mul_fixpt_tc u_matrix_mul_fixpt_tc (.clk(clk),
                                                         .reset(reset),
                                                         .clk_enable(clk_enable_1),
                                                         .enb_40_1_0(enb_40_1_0),
                                                         .enb_1_1_1(enb_1_1_1),
                                                         .count40(counter));*/
  reg [5:0] counter;

  // counter process
  always @(posedge clk) begin
      if (reset == 1'b1) begin
          counter <= 1'b0;
      end
      else if (clk_enable == 1'b1) begin
          counter <= 1'b0;
      end
      // counter increment
      else if (counter <= (5 + PIPE_DLY)) begin
          counter <= counter + 1'b1;
      end
      else begin
          counter <= counter;
      end
  end


  reg signed [(A_wid-1):0] a_in;
  reg signed [(B_wid-1):0] b_in;
  wire signed [(A_wid + B_wid -1):0] m_out;

  always @(posedge clk) begin 
    if (reset == 1'b1) begin
        a_in <= {(A_wid){1'b0}};
        b_in <= {(B_wid){1'b0}};
    end
    case(counter)
      0: begin 
        a_in <= {(A_wid){1'b0}};
        b_in <= {(B_wid){1'b0}};
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end
      1: begin
        a_in <= A[0];
        b_in <= B[0];
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end
      2: begin
        a_in <= A[1];
        b_in <= B[1];
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end
      3: begin
        a_in <= A[2];
        b_in <= B[0];
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end
      4: begin
        a_in <= A[3];
        b_in <= B[1];
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end
      5: begin 
        //$display("counter %d: A: %d B: %d", counter, a_in, b_in);
      end

      default: begin
        a_in <= {(A_wid){1'b0}};
        b_in <= {(B_wid){1'b0}};
      end
    endcase
  end  

  reg signed [(A_wid + B_wid + 1 - 1):0] out_tmp [0:1]; //

  always @(posedge clk) begin 
    if (reset == 1'b1) begin
        out_tmp[0] <= {(A_wid + B_wid + 1){1'b0}};
        out_tmp[1] <= {(A_wid + B_wid + 1){1'b0}};
        out_0 <= {(A_wid + B_wid + 1){1'b0}};
        out_1 <= {(A_wid + B_wid + 1){1'b0}};
        ce_out <= 1'b0; 
    end
    case(counter)
      0: begin 
        out_tmp[0] <= {(A_wid + B_wid + 1){1'b0}};
        out_tmp[1] <= {(A_wid + B_wid + 1){1'b0}};
        //$display("counter %d: out[0]: %d out[1]: %d", counter, out_tmp[0], out_tmp[1]);
      end
      0 + PIPE_DLY: begin 
        out_tmp[0] <= out_tmp[0] + {{1{m_out[A_wid + B_wid -1]}}, m_out};
        //$display("counter %d: Mult_out: %d out[0]: %d out[1]: %d", counter, m_out, out_tmp[0], out_tmp[1]);
      end
      1 + PIPE_DLY: begin
        out_tmp[0] <= out_tmp[0] + {{1{m_out[A_wid + B_wid -1]}}, m_out};
        //$display("counter %d: Mult_out: %d out[0]: %d out[1]: %d", counter, m_out, out_tmp[0], out_tmp[1]);
      end
      2 + PIPE_DLY: begin
        out_tmp[1] <= out_tmp[1] + {{1{m_out[A_wid + B_wid -1]}}, m_out};
        //$display("counter %d: Mult_out: %d out[0]: %d out[1]: %d", counter, m_out, out_tmp[0], out_tmp[1]);
      end
      3 + PIPE_DLY: begin
        out_tmp[1] <= out_tmp[1] + {{1{m_out[A_wid + B_wid -1]}}, m_out};
        //$display("counter %d: Mult_out: %d out[0]: %d out[1]: %d", counter, m_out, out_tmp[0], out_tmp[1]);
      end
      4 + PIPE_DLY: begin
        out_0 <= out_tmp[0]; 
        out_1 <= out_tmp[1];
        ce_out <= 1'b1;
        //$display("counter %d: Mult_out: %d out[0]: %d out[1]: %d", counter, m_out, out_tmp[0], out_tmp[1]);
      end
      5 + PIPE_DLY: begin
        //$display("CE high! counter %d: output ready. out_0 %d, out_1", counter, out_0, out_1);
        ce_out <= 1'b0;
      end

      default: begin
        ce_out <= 1'b0;
      end
    endcase
  end  

  //multiply_pipe #(.A_wid(A_wid), .B_wid(B_wid)) u2_mult(.clk(clk), .reset(reset), .a(a_in), .b(b_in), .out(m_out));
  
  //Use Xilinx Multiplier IP Instead - Note: Port Widths are not parameterizable
  mult_gen_2 u2_mult(.A(a_in), .B(b_in), .CLK(clk), .P(m_out), .SCLR(reset));

endmodule  

