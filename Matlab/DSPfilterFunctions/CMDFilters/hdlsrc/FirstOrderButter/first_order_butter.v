// -------------------------------------------------------------
//
// Module: first_order_butter
// Generated by MATLAB(R) 9.9 and Filter Design HDL Coder 3.1.8.
// Generated on: 2021-08-03 12:46:01
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// ResetType: Synchronous
// Name: first_order_butter
// CoefficientSource: ProcessorInterface
// TargetLanguage: Verilog
// TestBenchName: first_order_butter_tb
// TestBenchStimulus: step 
// TestBenchUserStimulus:  User data, length 2000
// ClockHighTime: 2.5
// ClockLowTime: 2.5

// Filter Specifications:
//
// Sample Rate   : 2.5 MHz
// Response      : Lowpass
// Specification : N,F3dB
// 3-dB Point    : 40 kHz
// Filter Order  : 1
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 1
// Stable              : Yes
// Linear Phase        : No
// Arithmetic          : fixed
// Numerator           : s32,30 -> [-2 2)
// Denominator         : s32,30 -> [-2 2)
// Scale Values        : s32,31 -> [-1 1)
// Input               : s32,31 -> [-1 1)
// Section Input       : s32,31 -> [-1 1)
// Section Output      : s32,31 -> [-1 1)
// Output              : s14,13 -> [-1 1)
// State               : s32,31 -> [-1 1)
// Numerator Prod      : s48,45 -> [-4 4)
// Denominator Prod    : s48,45 -> [-4 4)
// Numerator Accum     : s50,45 -> [-16 16)
// Denominator Accum   : s50,45 -> [-16 16)
// Round Mode          : convergent
// Overflow Mode       : saturate
// Cast Before Sum     : false
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module first_order_butter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                write_enable,
                write_done,
                write_address,
                coeffs_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [31:0] filter_in; //sfix32_En31
  input   write_enable; 
  input   write_done; 
  input   [2:0] write_address; //ufix3
  input   signed [31:0] coeffs_in; //sfix32
  output  signed [13:0] filter_out; //sfix14_En13

////////////////////////////////////////////////////////////////
//Module Architecture: first_order_butter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  // Signals
  reg  signed [31:0] input_register; // sfix32_En31
  reg  write_enable_reg; // boolean
  reg  write_done_reg; // boolean
  reg  [2:0] write_address_reg; // ufix3
  reg  signed [31:0] coeffs_in_reg; // sfix32
  // Section 1   Processor Interface Signals 
  wire signed [31:0] coeff_scale1_assigned; // sfix32_En31
  wire signed [31:0] coeff_scale1_temp; // sfix32_En31
  reg  signed [31:0] coeff_scale1_reg; // sfix32_En31
  reg  signed [31:0] coeff_scale1_shadow_reg; // sfix32_En31
  wire signed [31:0] scale1; // sfix32_En31
  wire signed [63:0] mul_temp; // sfix64_En62
  wire signed [31:0] coeff_b1_section1_assigned; // sfix32_En30
  wire signed [31:0] coeff_b1_section1_temp; // sfix32_En30
  reg  signed [31:0] coeff_b1_section1_reg; // sfix32_En30
  reg  signed [31:0] coeff_b1_section1_shadow_reg; // sfix32_En30
  wire signed [31:0] coeff_b2_section1_assigned; // sfix32_En30
  wire signed [31:0] coeff_b2_section1_temp; // sfix32_En30
  reg  signed [31:0] coeff_b2_section1_reg; // sfix32_En30
  reg  signed [31:0] coeff_b2_section1_shadow_reg; // sfix32_En30
  wire signed [31:0] coeff_a2_section1_assigned; // sfix32_En30
  wire signed [31:0] coeff_a2_section1_temp; // sfix32_En30
  reg  signed [31:0] coeff_a2_section1_reg; // sfix32_En30
  reg  signed [31:0] coeff_a2_section1_shadow_reg; // sfix32_En30
  //   -- Section 1 Signals 
  wire signed [49:0] a1sum1; // sfix50_En45
  wire signed [49:0] b1sum1; // sfix50_En45
  wire signed [31:0] a1sumtypeconvert1; // sfix32_En31
  reg  signed [31:0] delay_section1; // sfix32_En31
  wire signed [49:0] inputconv1; // sfix50_En45
  wire signed [47:0] a2mul1; // sfix48_En45
  wire signed [47:0] b1mul1; // sfix48_En45
  wire signed [47:0] b2mul1; // sfix48_En45
  wire signed [63:0] mul_temp_1; // sfix64_En61
  wire signed [63:0] mul_temp_2; // sfix64_En61
  wire signed [63:0] mul_temp_3; // sfix64_En61
  wire signed [49:0] sub_signext; // sfix50_En45
  wire signed [49:0] sub_signext_1; // sfix50_En45
  wire signed [50:0] sub_temp; // sfix51_En45
  wire signed [49:0] b1multypeconvert1; // sfix50_En45
  wire signed [49:0] add_signext; // sfix50_En45
  wire signed [49:0] add_signext_1; // sfix50_En45
  wire signed [50:0] add_temp; // sfix51_En45
  wire signed [31:0] section_result1; // sfix32_En31
  // Last Section Value --   Processor Interface Signals 
  wire signed [31:0] coeff_scale2_assigned; // sfix32_En31
  wire signed [31:0] coeff_scale2_temp; // sfix32_En31
  reg  signed [31:0] coeff_scale2_reg; // sfix32_En31
  reg  signed [31:0] coeff_scale2_shadow_reg; // sfix32_En31
  wire signed [13:0] scale2; // sfix14_En13
  wire signed [63:0] mul_temp_4; // sfix64_En62
  wire signed [13:0] output_typeconvert; // sfix14_En13
  reg  signed [13:0] output_register; // sfix14_En13

  // Block Statements
  always @ ( posedge clk)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
        write_enable_reg <= 1'b0;
        write_done_reg <= 1'b0;
        write_address_reg <= 0;
        coeffs_in_reg <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
          write_enable_reg <= write_enable;
          write_done_reg <= write_done;
          write_address_reg <= write_address;
          coeffs_in_reg <= coeffs_in;
        end
      end
    end // input_reg_process

  //   -------- Section 1 Processor Interface logic------------------

  assign mul_temp = input_register * coeff_scale1_shadow_reg;
  assign scale1 = ((mul_temp[63] == 1'b0 & mul_temp[62] != 1'b0) || (mul_temp[63] == 1'b0 && mul_temp[62:31] == 32'b01111111111111111111111111111111) // special case0
) ? 32'b01111111111111111111111111111111 : 
      (mul_temp[63] == 1'b1 && mul_temp[62] != 1'b1) ? 32'b10000000000000000000000000000000 : (mul_temp[62:0] + {mul_temp[31], {30{~mul_temp[31]}}})>>>31;

  assign coeff_scale1_assigned = (write_address_reg == 3'b000) ? coeffs_in_reg :
                           coeff_scale1_reg;
  assign coeff_scale1_temp = (write_enable_reg == 1'b1) ? coeff_scale1_assigned :
                       coeff_scale1_reg;
  assign coeff_b1_section1_assigned = (write_address_reg == 3'b001) ? coeffs_in_reg :
                                coeff_b1_section1_reg;
  assign coeff_b1_section1_temp = (write_enable_reg == 1'b1) ? coeff_b1_section1_assigned :
                            coeff_b1_section1_reg;
  assign coeff_b2_section1_assigned = (write_address_reg == 3'b010) ? coeffs_in_reg :
                                coeff_b2_section1_reg;
  assign coeff_b2_section1_temp = (write_enable_reg == 1'b1) ? coeff_b2_section1_assigned :
                            coeff_b2_section1_reg;
  assign coeff_a2_section1_assigned = (write_address_reg == 3'b100) ? coeffs_in_reg :
                                coeff_a2_section1_reg;
  assign coeff_a2_section1_temp = (write_enable_reg == 1'b1) ? coeff_a2_section1_assigned :
                            coeff_a2_section1_reg;
  always @ ( posedge clk)
    begin: coeff_reg_process_section1
      if (reset == 1'b1) begin
        coeff_scale1_reg <= 0;
        coeff_b1_section1_reg <= 0;
        coeff_b2_section1_reg <= 0;
        coeff_a2_section1_reg <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          coeff_scale1_reg <= coeff_scale1_temp;
          coeff_b1_section1_reg <= coeff_b1_section1_temp;
          coeff_b2_section1_reg <= coeff_b2_section1_temp;
          coeff_a2_section1_reg <= coeff_a2_section1_temp;
        end
      end
    end // coeff_reg_process_section1

  always @ ( posedge clk)
    begin: coeff_shadow_reg_process_section1
      if (reset == 1'b1) begin
        coeff_scale1_shadow_reg <= 0;
        coeff_b1_section1_shadow_reg <= 0;
        coeff_b2_section1_shadow_reg <= 0;
        coeff_a2_section1_shadow_reg <= 0;
      end
      else begin
        if (write_done_reg == 1'b1) begin
          coeff_scale1_shadow_reg <= coeff_scale1_reg;
          coeff_b1_section1_shadow_reg <= coeff_b1_section1_reg;
          coeff_b2_section1_shadow_reg <= coeff_b2_section1_reg;
          coeff_a2_section1_shadow_reg <= coeff_a2_section1_reg;
        end
      end
    end // coeff_shadow_reg_process_section1

  //   ------------------ Section 1 (First Order) ------------------

  assign a1sumtypeconvert1 = ((a1sum1[49] == 1'b0 & a1sum1[48:45] != 4'b0000) || (a1sum1[49] == 1'b0 && a1sum1[45:14] == 32'b01111111111111111111111111111111) // special case0
) ? 32'b01111111111111111111111111111111 : 
      (a1sum1[49] == 1'b1 && a1sum1[48:45] != 4'b1111) ? 32'b10000000000000000000000000000000 : (a1sum1[45:0] + {a1sum1[14], {13{~a1sum1[14]}}})>>>14;

  always @ ( posedge clk)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section1 <= a1sumtypeconvert1;
        end
      end
    end // delay_process_section1

  assign inputconv1 = $signed({scale1, 14'b00000000000000});

  assign mul_temp_1 = delay_section1 * coeff_a2_section1_shadow_reg;
  assign a2mul1 = (mul_temp_1[63] == 1'b0 && mul_temp_1[62:15] == 48'b111111111111111111111111111111111111111111111111) ? 48'b011111111111111111111111111111111111111111111111 : (mul_temp_1[63:0] + {mul_temp_1[16], {15{~mul_temp_1[16]}}})>>>16;

  assign mul_temp_2 = a1sumtypeconvert1 * coeff_b1_section1_shadow_reg;
  assign b1mul1 = (mul_temp_2[63] == 1'b0 && mul_temp_2[62:15] == 48'b111111111111111111111111111111111111111111111111) ? 48'b011111111111111111111111111111111111111111111111 : (mul_temp_2[63:0] + {mul_temp_2[16], {15{~mul_temp_2[16]}}})>>>16;

  assign mul_temp_3 = delay_section1 * coeff_b2_section1_shadow_reg;
  assign b2mul1 = (mul_temp_3[63] == 1'b0 && mul_temp_3[62:15] == 48'b111111111111111111111111111111111111111111111111) ? 48'b011111111111111111111111111111111111111111111111 : (mul_temp_3[63:0] + {mul_temp_3[16], {15{~mul_temp_3[16]}}})>>>16;

  assign sub_signext = inputconv1;
  assign sub_signext_1 = $signed({{2{a2mul1[47]}}, a2mul1});
  assign sub_temp = sub_signext - sub_signext_1;
  assign a1sum1 = ((sub_temp[50] == 1'b0 & sub_temp[49] != 1'b0) || (sub_temp[50] == 1'b0 && sub_temp[49:0] == 50'b01111111111111111111111111111111111111111111111111) // special case0
) ? 50'b01111111111111111111111111111111111111111111111111 : 
      (sub_temp[50] == 1'b1 && sub_temp[49] != 1'b1) ? 50'b10000000000000000000000000000000000000000000000000 : sub_temp[49:0];

  assign b1multypeconvert1 = $signed({{2{b1mul1[47]}}, b1mul1});

  assign add_signext = b1multypeconvert1;
  assign add_signext_1 = $signed({{2{b2mul1[47]}}, b2mul1});
  assign add_temp = add_signext + add_signext_1;
  assign b1sum1 = ((add_temp[50] == 1'b0 & add_temp[49] != 1'b0) || (add_temp[50] == 1'b0 && add_temp[49:0] == 50'b01111111111111111111111111111111111111111111111111) // special case0
) ? 50'b01111111111111111111111111111111111111111111111111 : 
      (add_temp[50] == 1'b1 && add_temp[49] != 1'b1) ? 50'b10000000000000000000000000000000000000000000000000 : add_temp[49:0];

  assign section_result1 = ((b1sum1[49] == 1'b0 & b1sum1[48:45] != 4'b0000) || (b1sum1[49] == 1'b0 && b1sum1[45:14] == 32'b01111111111111111111111111111111) // special case0
) ? 32'b01111111111111111111111111111111 : 
      (b1sum1[49] == 1'b1 && b1sum1[48:45] != 4'b1111) ? 32'b10000000000000000000000000000000 : (b1sum1[45:0] + {b1sum1[14], {13{~b1sum1[14]}}})>>>14;

  //   -------- Last Section Value -- Processor Interface logic------------------

  assign mul_temp_4 = section_result1 * coeff_scale2_shadow_reg;
  assign scale2 = ((mul_temp_4[63] == 1'b0 & mul_temp_4[62] != 1'b0) || (mul_temp_4[63] == 1'b0 && mul_temp_4[62:49] == 14'b01111111111111) // special case0
) ? 14'b01111111111111 : 
      (mul_temp_4[63] == 1'b1 && mul_temp_4[62] != 1'b1) ? 14'b10000000000000 : (mul_temp_4[62:0] + {mul_temp_4[49], {48{~mul_temp_4[49]}}})>>>49;

  assign coeff_scale2_assigned = (write_address_reg == 3'b111) ? coeffs_in_reg :
                           coeff_scale2_reg;
  assign coeff_scale2_temp = (write_enable_reg == 1'b1) ? coeff_scale2_assigned :
                       coeff_scale2_reg;
  always @ ( posedge clk)
    begin: coeff_reg_process_Last_ScaleValue
      if (reset == 1'b1) begin
        coeff_scale2_reg <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          coeff_scale2_reg <= coeff_scale2_temp;
        end
      end
    end // coeff_reg_process_Last_ScaleValue

  always @ ( posedge clk)
    begin: coeff_shadow_reg_process_Last_ScaleValue
      if (reset == 1'b1) begin
        coeff_scale2_shadow_reg <= 0;
      end
      else begin
        if (write_done_reg == 1'b1) begin
          coeff_scale2_shadow_reg <= coeff_scale2_reg;
        end
      end
    end // coeff_shadow_reg_process_Last_ScaleValue

  assign output_typeconvert = scale2;

  always @ ( posedge clk)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = output_register;
endmodule  // first_order_butter
