// -------------------------------------------------------------
// 
// File Name: /home/delg/Documents/covg_fpga_project/covg_fpga/Matlab/control_system/observer/observer/codegen/observer/hdlsrc/observer_fixpt.v
// Created: 2022-12-22 22:31:48
// 
// Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Design base rate: 0.025
// Explicit user oversample request: 40x
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// out_0                         ce_out        1
// out_1                         ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: observer_fixpt
// Source Path: observer_fixpt
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module observer_fixpt
          (clk,
           reset,
           clk_enable,
           y1,
           y2,
           u,
           L_0,
           L_1,
           L_2,
           L_3,
           A_0,
           A_1,
           A_2,
           A_3,
           B_0,
           B_1,
           ce_out,
           out_0,
           out_1);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [15:0] y1;  // sfix16_En15
  input   signed [15:0] y2;  // sfix16_En15
  input   signed [15:0] u;  // sfix16_En15
  input   signed [31:0] L_0;  // sfix32_En31
  input   signed [31:0] L_1;  // sfix32_En31
  input   signed [31:0] L_2;  // sfix32_En31
  input   signed [31:0] L_3;  // sfix32_En31
  input   signed [31:0] A_0;  // sfix32_En31
  input   signed [31:0] A_1;  // sfix32_En31
  input   signed [31:0] A_2;  // sfix32_En31
  input   signed [31:0] A_3;  // sfix32_En31
  input   signed [31:0] B_0;  // sfix32_En31
  input   signed [31:0] B_1;  // sfix32_En31
  output  ce_out;
  output  signed [15:0] out_0;  // sfix16_En13
  output  signed [15:0] out_1;  // sfix16_En13


  wire enb;
  wire enb_1_1_1;
  wire enb_40_1_0;
  wire signed [31:0] A [0:3];  // sfix32_En31 [4]
  wire signed [31:0] Am [0:3];  // sfix32_En31 [4]
  wire signed [65:0] c [0:1];  // sfix66_En61 [2]
  wire clk_enable_1;
  wire signed [31:0] B [0:1];  // sfix32_En31 [2]
  wire signed [31:0] Bm [0:1];  // sfix32_En31 [2]
  wire signed [31:0] L [0:3];  // sfix32_En31 [4]
  wire signed [31:0] Lm [0:3];  // sfix32_En31 [4]
  wire signed [15:0] y [0:1];  // sfix16_En15 [2]
  wire signed [48:0] c_1 [0:1];  // sfix49_En46 [2]
  reg signed [48:0] c_2 [0:1];  // sfix49_En46 [2]
  wire signed [48:0] c_3 [0:1];  // sfix49_En46 [2]
  wire signed [32:0] tmp [0:1];  // sfix33_En30 [2]
  wire signed [32:0] yest [0:1];  // sfix33_En30 [2]
  reg signed [32:0] yest_reg_reg [0:1];  // sfix33 [2]
  wire signed [32:0] yest_reg_reg_next [0:1];  // sfix33_En30 [2]
  wire signed [32:0] yest_1 [0:1];  // sfix33_En30 [2]
  reg signed [65:0] c_4 [0:1];  // sfix66_En61 [2]
  wire signed [65:0] c_5 [0:1];  // sfix66_En61 [2]
  wire signed [66:0] p11tmp_add_cast [0:1];  // sfix67_En61 [2]
  wire signed [47:0] p11tmp_mul_temp [0:1];  // sfix48_En46 [2]
  wire signed [66:0] p11tmp_add_cast_1 [0:1];  // sfix67_En61 [2]
  wire signed [66:0] p11tmp_add_temp [0:1];  // sfix67_En61 [2]
  wire signed [67:0] p11tmp_add_cast_2 [0:1];  // sfix68_En61 [2]
  wire signed [67:0] p11tmp_add_cast_3 [0:1];  // sfix68_En61 [2]
  wire signed [67:0] p11tmp_add_temp_1 [0:1];  // sfix68_En61 [2]
  wire signed [15:0] out [0:1];  // sfix16_En13 [2]
  reg signed [15:0] out_reg_reg [0:1];  // sfix16 [2]
  wire signed [15:0] out_reg_reg_next [0:1];  // sfix16_En13 [2]
  wire signed [15:0] out_2 [0:1];  // sfix16_En13 [2]
  reg signed [31:0] p1_k;  // int32
  reg signed [31:0] p1_l;  // int32
  reg signed [48:0] p1_slice_temp;  // sfix49_En46
  reg signed [49:0] p1_add_cast [0:1];  // sfix50_En46 [2]
  reg signed [63:0] p1_add_cast_0 [0:1];  // sfix64 [2]
  reg signed [47:0] p1_mul_temp [0:1];  // sfix48_En46 [2]
  reg signed [49:0] p1_add_cast_1 [0:1];  // sfix50_En46 [2]
  reg signed [49:0] p1_add_temp [0:1];  // sfix50_En46 [2]
  reg signed [31:0] p5_k;  // int32
  reg signed [31:0] p5_l;  // int32
  reg signed [65:0] p5_slice_temp;  // sfix66_En61
  reg signed [66:0] p5_add_cast [0:1];  // sfix67_En61 [2]
  reg signed [63:0] p5_add_cast_0 [0:1];  // sfix64 [2]
  reg signed [64:0] p5_mul_temp [0:1];  // sfix65_En61 [2]
  reg signed [66:0] p5_add_cast_1 [0:1];  // sfix67_En61 [2]
  reg signed [66:0] p5_add_temp [0:1];  // sfix67_En61 [2]


  assign A[0] = A_0;
  assign A[1] = A_1;
  assign A[2] = A_2;
  assign A[3] = A_3;

  assign Am[0] = A[0];
  assign Am[1] = A[1];
  assign Am[2] = A[2];
  assign Am[3] = A[3];



  // this is a Nx1 vector so reshape is uncessary 
  assign c[0] = 66'sh00000000000000000;
  assign c[1] = 66'sh00000000000000000;



  observer_fixpt_enb_bypass u_observer_fixpt_enb_bypass (.clk_1(clk),
                                                         .reset_1(reset),
                                                         .clk_enable_1(clk_enable),
                                                         .clk_enable_2(clk_enable_1)
                                                         );

  observer_fixpt_tc u_observer_fixpt_tc (.clk(clk),
                                         .reset(reset),
                                         .clk_enable(clk_enable_1),
                                         .enb_40_1_0(enb_40_1_0),
                                         .enb(enb),
                                         .enb_1_1_1(enb_1_1_1)
                                         );

  assign B[0] = B_0;
  assign B[1] = B_1;

  assign Bm[0] = B[0];
  assign Bm[1] = B[1];



  assign L[0] = L_0;
  assign L[1] = L_1;
  assign L[2] = L_2;
  assign L[3] = L_3;

  // HDL code generation from MATLAB function: observer_fixpt
  // 
  // y1, y2, y3, L, A, B
  // 
  // inputs 
  // 
  // fixed point design of x3 2x2 * 2x1 matrix multiplication and then sum
  // 
  // 2022/12/06
  // 
  // Lucas Koerner 
  // 
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // 
  //                                                                          %
  // 
  //          Generated by MATLAB 9.12 and Fixed-Point Designer 7.4           %
  // 
  //                                                                          %
  // 
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  assign Lm[0] = L[0];
  assign Lm[1] = L[1];
  assign Lm[2] = L[2];
  assign Lm[3] = L[3];



  assign y[0] = y1;
  assign y[1] = y2;



  assign c_1[0] = 49'sh0000000000000;
  assign c_1[1] = 49'sh0000000000000;



  always @* begin
    p1_slice_temp = 49'sh0000000000000;

    for(p1_l = 32'sd0; p1_l <= 32'sd1; p1_l = p1_l + 32'sd1) begin
      p1_slice_temp = c_1[p1_l];

      for(p1_k = 32'sd0; p1_k <= 32'sd1; p1_k = p1_k + 32'sd1) begin
        p1_add_cast[p1_k] = {p1_slice_temp[48], p1_slice_temp};
        p1_add_cast_0[p1_k] = {{31{p1_k[31]}}, {p1_k, 1'b0}};
        p1_mul_temp[p1_k] = Lm[p1_l + p1_add_cast_0[p1_k]] * y[p1_k];
        p1_add_cast_1[p1_k] = {{2{p1_mul_temp[p1_k][47]}}, p1_mul_temp[p1_k]};
        p1_add_temp[p1_k] = p1_add_cast[p1_k] + p1_add_cast_1[p1_k];
        p1_slice_temp = p1_add_temp[p1_k][48:0];
      end

      c_2[p1_l] = p1_slice_temp;
    end

  end



  assign c_3[0] = c_2[0];
  assign c_3[1] = c_2[1];



  always @(posedge clk or posedge reset)
    begin : yest_reg_process
      if (reset == 1'b1) begin
        yest_reg_reg[0] <= 33'sh000000000;
        yest_reg_reg[1] <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          yest_reg_reg[0] <= yest_reg_reg_next[0];
          yest_reg_reg[1] <= yest_reg_reg_next[1];
        end
      end
    end

  assign yest_1[0] = yest_reg_reg[0];
  assign yest_1[1] = yest_reg_reg[1];
  assign yest_reg_reg_next[0] = yest[0];
  assign yest_reg_reg_next[1] = yest[1];



  always @* begin
    p5_slice_temp = 66'sh00000000000000000;

    for(p5_l = 32'sd0; p5_l <= 32'sd1; p5_l = p5_l + 32'sd1) begin
      p5_slice_temp = c[p5_l];

      for(p5_k = 32'sd0; p5_k <= 32'sd1; p5_k = p5_k + 32'sd1) begin
        p5_add_cast[p5_k] = {p5_slice_temp[65], p5_slice_temp};
        p5_add_cast_0[p5_k] = {{31{p5_k[31]}}, {p5_k, 1'b0}};
        p5_mul_temp[p5_k] = Am[p5_l + p5_add_cast_0[p5_k]] * yest_1[p5_k];
        p5_add_cast_1[p5_k] = {{2{p5_mul_temp[p5_k][64]}}, p5_mul_temp[p5_k]};
        p5_add_temp[p5_k] = p5_add_cast[p5_k] + p5_add_cast_1[p5_k];
        p5_slice_temp = p5_add_temp[p5_k][65:0];
      end

      c_4[p5_l] = p5_slice_temp;
    end

  end



  assign c_5[0] = c_4[0];
  assign c_5[1] = c_4[1];



  assign p11tmp_add_cast[0] = {c_5[0][65], c_5[0]};
  assign p11tmp_mul_temp[0] = Bm[0] * u;
  assign p11tmp_add_cast_1[0] = {{4{p11tmp_mul_temp[0][47]}}, {p11tmp_mul_temp[0], 15'b000000000000000}};
  assign p11tmp_add_temp[0] = p11tmp_add_cast[0] + p11tmp_add_cast_1[0];
  assign p11tmp_add_cast_2[0] = {p11tmp_add_temp[0][66], p11tmp_add_temp[0]};
  assign p11tmp_add_cast_3[0] = {{4{c_3[0][48]}}, {c_3[0], 15'b000000000000000}};
  assign p11tmp_add_temp_1[0] = p11tmp_add_cast_2[0] + p11tmp_add_cast_3[0];
  assign tmp[0] = p11tmp_add_temp_1[0][63:31];
  assign p11tmp_add_cast[1] = {c_5[1][65], c_5[1]};
  assign p11tmp_mul_temp[1] = Bm[1] * u;
  assign p11tmp_add_cast_1[1] = {{4{p11tmp_mul_temp[1][47]}}, {p11tmp_mul_temp[1], 15'b000000000000000}};
  assign p11tmp_add_temp[1] = p11tmp_add_cast[1] + p11tmp_add_cast_1[1];
  assign p11tmp_add_cast_2[1] = {p11tmp_add_temp[1][66], p11tmp_add_temp[1]};
  assign p11tmp_add_cast_3[1] = {{4{c_3[1][48]}}, {c_3[1], 15'b000000000000000}};
  assign p11tmp_add_temp_1[1] = p11tmp_add_cast_2[1] + p11tmp_add_cast_3[1];
  assign tmp[1] = p11tmp_add_temp_1[1][63:31];



  assign yest[0] = tmp[0];
  assign yest[1] = tmp[1];

  assign out[0] = yest[0][32:17];
  assign out[1] = yest[1][32:17];



  always @(posedge clk or posedge reset)
    begin : out_reg_process
      if (reset == 1'b1) begin
        out_reg_reg[0] <= 16'sb0000000000000000;
        out_reg_reg[1] <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          out_reg_reg[0] <= out_reg_reg_next[0];
          out_reg_reg[1] <= out_reg_reg_next[1];
        end
      end
    end

  assign out_2[0] = out_reg_reg[0];
  assign out_2[1] = out_reg_reg[1];
  assign out_reg_reg_next[0] = out[0];
  assign out_reg_reg_next[1] = out[1];



  assign out_0 = out_2[0];

  assign out_1 = out_2[1];

  assign ce_out = enb_1_1_1;

endmodule  // observer_fixpt

